{
    "version": "https://jsonfeed.org/version/1",
    "title": "Learning-Sharing-Recording",
    "subtitle": "To be,or not to be,that is the question",
    "icon": "https://lzq-cv.github.io/images/favicon.ico",
    "description": "CV Engineer",
    "home_page_url": "https://LZQ-CV.github.io",
    "items": [
        {
            "id": "https://lzq-cv.github.io/python%E9%81%8D%E5%8E%86%E6%8C%87%E5%AE%9A%E8%B7%AF%E5%BE%84%E7%9A%84%E5%9B%BE%E7%89%87/",
            "url": "https://lzq-cv.github.io/python%E9%81%8D%E5%8E%86%E6%8C%87%E5%AE%9A%E8%B7%AF%E5%BE%84%E7%9A%84%E5%9B%BE%E7%89%87/",
            "title": "python遍历指定路径的图片",
            "date_published": "2025-09-30T12:19:43.000Z",
            "content_html": "<p>在 Python 中，可以使用多种方式遍历指定文件夹中的图片文件。以下是几种常见的实现方法：</p>\n<h2 id=\"方法1使用os模块基础版\"><a class=\"anchor\" href=\"#方法1使用os模块基础版\">#</a> 方法 1：使用 os 模块（基础版）</h2>\n<p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">traverse_images_os</span>(<span class=\"params\">folder_path</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;使用os模块遍历图片&quot;&quot;&quot;</span></span><br><span class=\"line\">    image_extensions = [<span class=\"string\">&#x27;.jpg&#x27;</span>, <span class=\"string\">&#x27;.jpeg&#x27;</span>, <span class=\"string\">&#x27;.png&#x27;</span>, <span class=\"string\">&#x27;.gif&#x27;</span>, <span class=\"string\">&#x27;.bmp&#x27;</span>, <span class=\"string\">&#x27;.tiff&#x27;</span>, <span class=\"string\">&#x27;.webp&#x27;</span>]</span><br><span class=\"line\">    image_files = []</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> filename <span class=\"keyword\">in</span> os.listdir(folder_path):</span><br><span class=\"line\">        <span class=\"comment\"># 获取文件扩展名并转换为小写</span></span><br><span class=\"line\">        ext = os.path.splitext(filename)[<span class=\"number\">1</span>].lower()</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ext <span class=\"keyword\">in</span> image_extensions:</span><br><span class=\"line\">            full_path = os.path.join(folder_path, filename)</span><br><span class=\"line\">            image_files.append(full_path)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> image_files</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用示例</span></span><br><span class=\"line\">folder = <span class=\"string\">&quot;your/image/folder/path&quot;</span></span><br><span class=\"line\">images = traverse_images_os(folder)</span><br><span class=\"line\"><span class=\"keyword\">for</span> img <span class=\"keyword\">in</span> images:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(img)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"方法2使用pathlib模块推荐\"><a class=\"anchor\" href=\"#方法2使用pathlib模块推荐\">#</a> 方法 2：使用 pathlib 模块（推荐）</h2>\n<p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pathlib <span class=\"keyword\">import</span> Path</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">traverse_images_pathlib</span>(<span class=\"params\">folder_path</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;使用pathlib模块遍历图片（Python 3.4+）&quot;&quot;&quot;</span></span><br><span class=\"line\">    image_extensions = &#123;<span class=\"string\">&#x27;.jpg&#x27;</span>, <span class=\"string\">&#x27;.jpeg&#x27;</span>, <span class=\"string\">&#x27;.png&#x27;</span>, <span class=\"string\">&#x27;.gif&#x27;</span>, <span class=\"string\">&#x27;.bmp&#x27;</span>, <span class=\"string\">&#x27;.tiff&#x27;</span>, <span class=\"string\">&#x27;.webp&#x27;</span>&#125;</span><br><span class=\"line\">    folder = Path(folder_path)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 使用列表推导式</span></span><br><span class=\"line\">    image_files = [</span><br><span class=\"line\">        <span class=\"built_in\">str</span>(file) <span class=\"keyword\">for</span> file <span class=\"keyword\">in</span> folder.iterdir() </span><br><span class=\"line\">        <span class=\"keyword\">if</span> file.is_file() <span class=\"keyword\">and</span> file.suffix.lower() <span class=\"keyword\">in</span> image_extensions</span><br><span class=\"line\">    ]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> image_files</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用示例</span></span><br><span class=\"line\">folder = <span class=\"string\">&quot;your/image/folder/path&quot;</span></span><br><span class=\"line\">images = traverse_images_pathlib(folder)</span><br><span class=\"line\"><span class=\"keyword\">for</span> img <span class=\"keyword\">in</span> images:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(img)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"方法3递归遍历子文件夹\"><a class=\"anchor\" href=\"#方法3递归遍历子文件夹\">#</a> 方法 3：递归遍历子文件夹</h2>\n<p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">from</span> pathlib <span class=\"keyword\">import</span> Path</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">traverse_images_recursive</span>(<span class=\"params\">folder_path</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;递归遍历文件夹及其所有子文件夹中的图片&quot;&quot;&quot;</span></span><br><span class=\"line\">    image_extensions = &#123;<span class=\"string\">&#x27;.jpg&#x27;</span>, <span class=\"string\">&#x27;.jpeg&#x27;</span>, <span class=\"string\">&#x27;.png&#x27;</span>, <span class=\"string\">&#x27;.gif&#x27;</span>, <span class=\"string\">&#x27;.bmp&#x27;</span>, <span class=\"string\">&#x27;.tiff&#x27;</span>, <span class=\"string\">&#x27;.webp&#x27;</span>&#125;</span><br><span class=\"line\">    folder = Path(folder_path)</span><br><span class=\"line\">    image_files = []</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># 使用rglob递归遍历</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> file_path <span class=\"keyword\">in</span> folder.rglob(<span class=\"string\">&#x27;*&#x27;</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> file_path.is_file() <span class=\"keyword\">and</span> file_path.suffix.lower() <span class=\"keyword\">in</span> image_extensions:</span><br><span class=\"line\">            image_files.append(<span class=\"built_in\">str</span>(file_path))</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> image_files</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用示例</span></span><br><span class=\"line\">folder = <span class=\"string\">&quot;your/image/folder/path&quot;</span></span><br><span class=\"line\">images = traverse_images_recursive(folder)</span><br><span class=\"line\"><span class=\"keyword\">for</span> img <span class=\"keyword\">in</span> images:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(img)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"方法4使用glob模块\"><a class=\"anchor\" href=\"#方法4使用glob模块\">#</a> 方法 4：使用 glob 模块</h2>\n<p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> glob</span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">traverse_images_glob</span>(<span class=\"params\">folder_path</span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;使用glob模块遍历图片&quot;&quot;&quot;</span></span><br><span class=\"line\">    <span class=\"comment\"># 支持的图片格式模式</span></span><br><span class=\"line\">    patterns = [</span><br><span class=\"line\">        <span class=\"string\">&#x27;*.jpg&#x27;</span>, <span class=\"string\">&#x27;*.jpeg&#x27;</span>, <span class=\"string\">&#x27;*.png&#x27;</span>, <span class=\"string\">&#x27;*.gif&#x27;</span>, </span><br><span class=\"line\">        <span class=\"string\">&#x27;*.bmp&#x27;</span>, <span class=\"string\">&#x27;*.tiff&#x27;</span>, <span class=\"string\">&#x27;*.webp&#x27;</span></span><br><span class=\"line\">    ]</span><br><span class=\"line\">    </span><br><span class=\"line\">    image_files = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> pattern <span class=\"keyword\">in</span> patterns:</span><br><span class=\"line\">        <span class=\"comment\"># 搜索所有匹配的文件</span></span><br><span class=\"line\">        search_pattern = os.path.join(folder_path, pattern)</span><br><span class=\"line\">        image_files.extend(glob.glob(search_pattern))</span><br><span class=\"line\">        <span class=\"comment\"># 同时搜索大写扩展名</span></span><br><span class=\"line\">        search_pattern_upper = os.path.join(folder_path, pattern.upper())</span><br><span class=\"line\">        image_files.extend(glob.glob(search_pattern_upper))</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">list</span>(<span class=\"built_in\">set</span>(image_files))  <span class=\"comment\"># 去重</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用示例</span></span><br><span class=\"line\">folder = <span class=\"string\">&quot;your/image/folder/path&quot;</span></span><br><span class=\"line\">images = traverse_images_glob(folder)</span><br><span class=\"line\"><span class=\"keyword\">for</span> img <span class=\"keyword\">in</span> images:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(img)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"方法5完整的图片遍历类\"><a class=\"anchor\" href=\"#方法5完整的图片遍历类\">#</a> 方法 5：完整的图片遍历类</h2>\n<p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">from</span> pathlib <span class=\"keyword\">import</span> Path</span><br><span class=\"line\"><span class=\"keyword\">from</span> typing <span class=\"keyword\">import</span> <span class=\"type\">List</span>, Generator</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">ImageTraverser</span>:</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;图片遍历器类&quot;&quot;&quot;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, supported_extensions=<span class=\"literal\">None</span></span>):</span><br><span class=\"line\">        <span class=\"variable language_\">self</span>.supported_extensions = supported_extensions <span class=\"keyword\">or</span> [</span><br><span class=\"line\">            <span class=\"string\">&#x27;.jpg&#x27;</span>, <span class=\"string\">&#x27;.jpeg&#x27;</span>, <span class=\"string\">&#x27;.png&#x27;</span>, <span class=\"string\">&#x27;.gif&#x27;</span>, <span class=\"string\">&#x27;.bmp&#x27;</span>, <span class=\"string\">&#x27;.tiff&#x27;</span>, <span class=\"string\">&#x27;.webp&#x27;</span></span><br><span class=\"line\">        ]</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">traverse</span>(<span class=\"params\">self, folder_path: <span class=\"built_in\">str</span>, recursive: <span class=\"built_in\">bool</span> = <span class=\"literal\">False</span></span>) -&gt; <span class=\"type\">List</span>[<span class=\"built_in\">str</span>]:</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;遍历文件夹中的图片文件&quot;&quot;&quot;</span></span><br><span class=\"line\">        folder = Path(folder_path)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> folder.exists():</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">f&quot;文件夹不存在: <span class=\"subst\">&#123;folder_path&#125;</span>&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> recursive:</span><br><span class=\"line\">            <span class=\"comment\"># 递归遍历</span></span><br><span class=\"line\">            image_files = [</span><br><span class=\"line\">                <span class=\"built_in\">str</span>(file) <span class=\"keyword\">for</span> file <span class=\"keyword\">in</span> folder.rglob(<span class=\"string\">&#x27;*&#x27;</span>)</span><br><span class=\"line\">                <span class=\"keyword\">if</span> file.is_file() <span class=\"keyword\">and</span> file.suffix.lower() <span class=\"keyword\">in</span> <span class=\"variable language_\">self</span>.supported_extensions</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"comment\"># 非递归遍历</span></span><br><span class=\"line\">            image_files = [</span><br><span class=\"line\">                <span class=\"built_in\">str</span>(file) <span class=\"keyword\">for</span> file <span class=\"keyword\">in</span> folder.iterdir()</span><br><span class=\"line\">                <span class=\"keyword\">if</span> file.is_file() <span class=\"keyword\">and</span> file.suffix.lower() <span class=\"keyword\">in</span> <span class=\"variable language_\">self</span>.supported_extensions</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">return</span> image_files</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">traverse_generator</span>(<span class=\"params\">self, folder_path: <span class=\"built_in\">str</span>, recursive: <span class=\"built_in\">bool</span> = <span class=\"literal\">False</span></span>) -&gt; Generator[<span class=\"built_in\">str</span>, <span class=\"literal\">None</span>, <span class=\"literal\">None</span>]:</span><br><span class=\"line\">        <span class=\"string\">&quot;&quot;&quot;生成器方式遍历图片（节省内存）&quot;&quot;&quot;</span></span><br><span class=\"line\">        folder = Path(folder_path)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> folder.exists():</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">f&quot;文件夹不存在: <span class=\"subst\">&#123;folder_path&#125;</span>&quot;</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> recursive:</span><br><span class=\"line\">            iterator = folder.rglob(<span class=\"string\">&#x27;*&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            iterator = folder.iterdir()</span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">for</span> file_path <span class=\"keyword\">in</span> iterator:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> file_path.is_file() <span class=\"keyword\">and</span> file_path.suffix.lower() <span class=\"keyword\">in</span> <span class=\"variable language_\">self</span>.supported_extensions:</span><br><span class=\"line\">                <span class=\"keyword\">yield</span> <span class=\"built_in\">str</span>(file_path)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用示例</span></span><br><span class=\"line\">traverser = ImageTraverser()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 非递归遍历</span></span><br><span class=\"line\">images = traverser.traverse(<span class=\"string\">&quot;your/image/folder/path&quot;</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> img <span class=\"keyword\">in</span> images:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(img)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 递归遍历</span></span><br><span class=\"line\">images_recursive = traverser.traverse(<span class=\"string\">&quot;your/image/folder/path&quot;</span>, recursive=<span class=\"literal\">True</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> img <span class=\"keyword\">in</span> images_recursive:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(img)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用生成器（节省内存）</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> img_path <span class=\"keyword\">in</span> traverser.traverse_generator(<span class=\"string\">&quot;your/image/folder/path&quot;</span>, recursive=<span class=\"literal\">True</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(img_path)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"方法6带文件信息的高级遍历\"><a class=\"anchor\" href=\"#方法6带文件信息的高级遍历\">#</a> 方法 6：带文件信息的高级遍历</h2>\n<p><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">from</span> pathlib <span class=\"keyword\">import</span> Path</span><br><span class=\"line\"><span class=\"keyword\">from</span> datetime <span class=\"keyword\">import</span> datetime</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">traverse_images_with_info</span>(<span class=\"params\">folder_path, recursive=<span class=\"literal\">False</span></span>):</span><br><span class=\"line\">    <span class=\"string\">&quot;&quot;&quot;遍历图片并返回详细信息&quot;&quot;&quot;</span></span><br><span class=\"line\">    image_extensions = &#123;<span class=\"string\">&#x27;.jpg&#x27;</span>, <span class=\"string\">&#x27;.jpeg&#x27;</span>, <span class=\"string\">&#x27;.png&#x27;</span>, <span class=\"string\">&#x27;.gif&#x27;</span>, <span class=\"string\">&#x27;.bmp&#x27;</span>, <span class=\"string\">&#x27;.tiff&#x27;</span>, <span class=\"string\">&#x27;.webp&#x27;</span>&#125;</span><br><span class=\"line\">    folder = Path(folder_path)</span><br><span class=\"line\">    </span><br><span class=\"line\">    image_info = []</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> recursive:</span><br><span class=\"line\">        file_iterator = folder.rglob(<span class=\"string\">&#x27;*&#x27;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        file_iterator = folder.iterdir()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">for</span> file_path <span class=\"keyword\">in</span> file_iterator:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> file_path.is_file() <span class=\"keyword\">and</span> file_path.suffix.lower() <span class=\"keyword\">in</span> image_extensions:</span><br><span class=\"line\">            stat = file_path.stat()</span><br><span class=\"line\">            info = &#123;</span><br><span class=\"line\">                <span class=\"string\">&#x27;path&#x27;</span>: <span class=\"built_in\">str</span>(file_path),</span><br><span class=\"line\">                <span class=\"string\">&#x27;name&#x27;</span>: file_path.name,</span><br><span class=\"line\">                <span class=\"string\">&#x27;size&#x27;</span>: stat.st_size,  <span class=\"comment\"># 文件大小（字节）</span></span><br><span class=\"line\">                <span class=\"string\">&#x27;created&#x27;</span>: datetime.fromtimestamp(stat.st_ctime),  <span class=\"comment\"># 创建时间</span></span><br><span class=\"line\">                <span class=\"string\">&#x27;modified&#x27;</span>: datetime.fromtimestamp(stat.st_mtime),  <span class=\"comment\"># 修改时间</span></span><br><span class=\"line\">                <span class=\"string\">&#x27;extension&#x27;</span>: file_path.suffix.lower()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            image_info.append(info)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> image_info</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用示例</span></span><br><span class=\"line\">folder = <span class=\"string\">&quot;your/image/folder/path&quot;</span></span><br><span class=\"line\">images_info = traverse_images_with_info(folder, recursive=<span class=\"literal\">True</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> info <span class=\"keyword\">in</span> images_info:</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;文件名: <span class=\"subst\">&#123;info[<span class=\"string\">&#x27;name&#x27;</span>]&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;路径: <span class=\"subst\">&#123;info[<span class=\"string\">&#x27;path&#x27;</span>]&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;大小: <span class=\"subst\">&#123;info[<span class=\"string\">&#x27;size&#x27;</span>]&#125;</span> 字节&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">f&quot;修改时间: <span class=\"subst\">&#123;info[<span class=\"string\">&#x27;modified&#x27;</span>]&#125;</span>&quot;</span>)</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"string\">&quot;-&quot;</span> * <span class=\"number\">50</span>)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用建议\"><a class=\"anchor\" href=\"#使用建议\">#</a> 使用建议</h2>\n<ol>\n<li><strong>推荐使用方法 2（pathlib）</strong>：代码更简洁，跨平台兼容性好</li>\n<li><strong>需要递归遍历时使用方法 3 或 5</strong>：可以处理嵌套的文件夹结构</li>\n<li><strong>处理大量文件时使用方法 5 的生成器版本</strong>：节省内存</li>\n<li><strong>需要文件详细信息时使用方法 6</strong>：获取大小、时间等元数据</li>\n</ol>\n",
            "tags": [
                "python"
            ]
        },
        {
            "id": "https://lzq-cv.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%BB%E8%A6%81%E6%9C%AF%E8%AF%AD/",
            "url": "https://lzq-cv.github.io/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%BB%E8%A6%81%E6%9C%AF%E8%AF%AD/",
            "title": "机器学习和深度学习的主要术语",
            "date_published": "2025-09-30T11:30:42.000Z",
            "content_html": "<h1 id=\"机器学习和深度学习的主要术语\"><a class=\"anchor\" href=\"#机器学习和深度学习的主要术语\">#</a> 机器学习和深度学习的主要术语</h1>\n<p>机器学习和深度学习是当前人工智能领域的两个重要分支。这些术语通常在讨论该领域时使用，因此了解这些术语对于理解相关概念和技术非常重要。</p>\n<ol>\n<li>机器学习（Machine Learning）<br />\n机器学习是人工智能的一个子领域，它让计算机系统从数据中学习并自主地进行决策和预测。它包括监督学习、无监督学习和强化学习等多种类型。</li>\n<li>深度学习（Deep Learning）<br />\n深度学习是机器学习的一个子领域，它利用人工神经网络进行学习和预测。深度学习可以处理包含多层抽象概念的复杂数据，例如图像、语音和自然语言文本。</li>\n<li>监督学习（Supervised Learning）<br />\n监督学习是一种机器学习技术，它在有标签数据集上进行训练，以预测某个结果或输出。例如，训练一个分类器来识别图像中的猫。</li>\n<li>无监督学习（Unsupervised Learning）<br />\n无监督学习是一种机器学习技术，它在没有标签的数据集上进行训练，以发现数据的结构和特征。例如，聚类分析可以将相似的数据点分组在一起。</li>\n<li>强化学习（Reinforcement Learning）<br />\n强化学习是一种机器学习技术，它通过让智能体在环境中执行一系列行动并获得奖励或惩罚来学习最优行为策略。例如，训练一个自动驾驶汽车在行驶过程中遵循交通规则并避免事故。</li>\n<li>人工神经网络（Artificial Neural Network）<br />\n人工神经网络是一种模拟人脑神经元网络的计算模型，它通过模拟神经元之间的复杂交互关系来处理和分析数据。深度学习使用多层人工神经网络来提取数据中的特征并建立复杂模型。</li>\n<li>卷积神经网络（Convolutional Neural Network）<br />\n卷积神经网络是一种特殊的人工神经网络，它专门用于处理具有网格结构的数据，如图像。它在图像识别、语音识别和自然语言处理等领域得到了广泛应用。</li>\n<li>循环神经网络（Recurrent Neural Network）<br />\n循环神经网络是一种人工神经网络，它使用循环结构来处理序列数据，如时间序列、文本和语音。它可以处理具有顺序和时间依赖性的数据，因此在自然语言处理和语音识别等领域很受欢迎。</li>\n<li>迁移学习（Transfer Learning）<br />\n迁移学习是一种利用已经在一个领域或任务上训练过的模型来处理另一个相关领域或任务的技术。这种技术可以大大减少在新任务上训练模型所需的时间和数据量。</li>\n<li>过拟合（Overfitting）<br />\n过拟合是指模型在训练数据上表现良好，但在测试数据上表现不佳的现象。这是由于模型对训练数据进行了过度拟合，导致其对新数据的泛化能力下降。</li>\n<li>欠拟合（Underfitting）<br />\n欠拟合是指模型在训练数据上和测试数据上都表现不佳的现象。这是由于模型过于简单，无法捕捉到数据中的复杂模式或特征。<br />\n以上是一些常用的机器学习和深度学习术语及其英文表达。这些术语在讨论相关领域时经常使用，因此掌握这些术语对于理解机器学习和深度学习的最新发展非常有帮助。</li>\n</ol>\n",
            "tags": [
                "Artificial-Intelligence",
                "Deep-Learning",
                "深度学习",
                "机器学习"
            ]
        },
        {
            "id": "https://lzq-cv.github.io/100%E4%B8%AA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%9C%AF%E8%AF%AD/",
            "url": "https://lzq-cv.github.io/100%E4%B8%AA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%9C%AF%E8%AF%AD/",
            "title": "100个深度学习术语",
            "date_published": "2025-09-30T11:28:47.000Z",
            "content_html": "<h1 id=\"100-个深度学习术语\"><a class=\"anchor\" href=\"#100-个深度学习术语\">#</a> 100 个深度学习术语</h1>\n<p><strong>1. 人工神经网络 (ANN)</strong> ANN 代表 Artificial Neural Network（人工神经网络）。在数据科学中，它指的是一种计算模型，其灵感大致来源于人脑的结构和功能。</p>\n<p><strong>2. 激活函数 (Activation Function)</strong> 激活函数计算加权总和，然后添加偏置，以决定神经元是否应该被激活。它的目的是在神经元的输出中引入非线性。示例包括 Sigmoid、ReLU（Rectified Linear Unit，修正线性单元）和 Tanh。</p>\n<p><strong>3. 反向传播 (Backpropagation)</strong> 在神经网络中，如果估计的输出与实际输出相差甚远（误差较大），我们会根据误差更新偏置和权重。这种权重和偏置更新过程被称为反向传播 (Back Propagation)。反向传播 (BP) 算法确定输出端的损失（或误差），然后将其反向传播到网络中。权重被更新以最小化每个神经元产生的误差。减少误差的第一步是确定每个节点相对于最终输出的梯度（导数）。</p>\n<p><strong>4. 卷积神经网络 (CNN)</strong> 卷积神经网络 (CNNs) 是一种强大的深度学习模型，擅长处理具有网格状结构的数据，主要是图像。它们的灵感来自人类视觉皮层的功能方式，尤其擅长图像识别、物体检测和图像分割等任务。</p>\n<p><strong>5. 深度学习 (Deep Learning)</strong> 深度学习与一种机器学习算法（人工神经网络，ANN）相关联，该算法使用人脑概念来促进任意函数的建模。 ANN 需要大量数据，并且这种算法在同时建模多个输出时非常灵活）。</p>\n<p><strong>6. 轮次 (Epoch)</strong> 这个深度学习术语 —— 轮次 (epoch)，指的是训练数据集在机器学习模型中完成一次完整传递。想象一个循环，您在其中对模型进行一次数据集中所有数据点的训练。每次完成该循环都被视为一个轮次。</p>\n<p><strong>7. 特征提取 (Feature Extraction)</strong> 特征提取指的是将原始数据转换为可以处理的数值特征，同时保留原始数据集中的信息。</p>\n<p><strong>8. 梯度下降 (Gradient Descent)</strong> 梯度下降是一种一阶迭代优化算法，用于寻找函数的最小值。我们在机器学习算法中使用梯度下降算法来最小化成本函数。它找出我们算法的最佳参数集。梯度下降可以分为以下几类：</p>\n<ul>\n<li>基于数据摄取：\n<ul>\n<li>全批量梯度下降算法 (Full Batch Gradient Descent Algorithm)</li>\n<li>随机梯度下降算法 (Stochastic Gradient Descent Algorithm)</li>\n<li>在全批量梯度下降算法中，我们一次使用所有数据来计算梯度，而在随机梯度下降算法中，我们在计算梯度时抽取一个样本。</li>\n</ul>\n</li>\n<li>基于微分技术：\n<ul>\n<li>一阶微分 (First order Differentiation)</li>\n<li>二阶微分 (Second order Differentiation)</li>\n</ul>\n</li>\n</ul>\n<p><strong>9. 损失函数 (Loss Function)</strong> 一种衡量神经网络对预期结果建模效果的函数。</p>\n<p><strong>10. 循环神经网络 (RNN)</strong> RNN 代表 Recurrent Neural Network（循环神经网络）。与逐点处理数据的传统 ANN 不同，RNN 专门设计用于处理顺序数据，其中信息的顺序很重要。</p>\n<p><strong>11. 迁移学习 (Transfer Learning)</strong> 迁移学习是将预训练模型应用于全新的数据集。预训练模型是由他人创建的用于解决问题的模型。该模型可以应用于解决具有相似数据的类似问题。</p>\n<p>在这里，您可以查看一些最广泛使用的预训练模型 (<em>请替换为实际链接</em>)。</p>\n<p><strong>12. 权重 (Weight)</strong> 神经网络中的一个参数，用于转换网络层内的输入数据。它在训练期间进行调整，以便网络预测正确的输出。</p>\n<p><strong>13. 偏置 (Bias)</strong> 添加到模型输出中的一个项，使模型能够表示不通过原点的模式。</p>\n<p><strong>14. 过拟合 (Overfitting)</strong> 当模型在训练数据集上表现良好，但在测试集上失败时，就说模型过拟合。当模型过于敏感并捕获仅存在于训练数据集中的随机模式时，就会发生这种情况。有两种方法可以克服过拟合：</p>\n<ul>\n<li>降低模型复杂度 (Reduce the model complexity)</li>\n<li>正则化 (Regularization)</li>\n</ul>\n<p><strong>15. 欠拟合 (Underfitting)</strong> 当统计模型或机器学习算法无法捕获数据的潜在趋势时，就会发生欠拟合。它指的是一个既不能对训练数据进行建模，也不能推广到新数据的模型。欠拟合模型是不合适的，因为它在训练数据上的表现会很差。</p>\n<p><strong>16. 正则化 (Regularization)</strong> 正则化是一种用于解决统计模型中过拟合问题的技术。在机器学习中，正则化会惩罚系数，以便模型可以更好地泛化。不同的回归技术使用正则化，例如岭回归 (Ridge regression) 和 Lasso 回归 (lasso regression)。</p>\n<p><strong>17. Dropout</strong> 一种用于神经网络的正则化技术，通过在训练期间的每次更新时随机将一部分输入单元设置为零来防止过拟合。</p>\n<p><strong>18. 批归一化 (Batch Normalization)</strong> 一种改进深度神经网络训练的技术，它对每个小批量 (mini-batch) 的层输入进行归一化。</p>\n<p><strong>19. 自编码器 (Autoencoder)</strong> 一种用于学习未标记数据的高效编码的神经网络，通常用于降维。</p>\n<p><strong>20. 生成对抗网络 (GAN)</strong> 生成对抗网络 (GAN)：Ian Goodfellow 及其同事设计了一类机器学习框架，其中两个神经网络在一个游戏中竞争。</p>\n<p><strong>21. 注意力机制 (Attention Mechanism)</strong> 复杂神经网络中的一个组件，尤其是在序列到序列模型中，它允许网络顺序关注输入的不同部分，而不是同时考虑整个输入，从而提高机器翻译等任务的性能。</p>\n<p><strong>22. 嵌入层 (Embedding Layer)</strong> 这个深度学习术语主要用于神经网络中处理文本数据，嵌入层将稀疏的分类数据（通常是单词的索引）转换为密集且连续的向量空间，其中相似的值彼此接近，从而促进更有效的学习。</p>\n<p><strong>23. 多层感知器 (MLP)</strong> 一种神经网络，至少包含三层节点：输入层、一个或多个隐藏层和输出层。与 CNN 或 RNN 不同，MLP 是完全连接的，这意味着一层中的每个神经元都连接到下一层中的每个神经元。</p>\n<p><strong>24. 归一化 (Normalization)</strong> 数据准备中的一个过程，它改变像素强度值的范围，以确保它们更加一致，通常通过确保输入的均值和标准差分别为 0 和 1。</p>\n<p><strong>25. 池化层 (Pooling Layer)</strong> 这个深度学习术语通常用于卷积神经网络中。池化（或子采样或下采样）通过将一层中神经元簇的输出组合到下一层中的单个神经元中来减小数据的维度，通常使用最大池化 (max pooling) 或平均池化 (average pooling) 方法。</p>\n<p><strong>26. 序列到序列模型 (Sequence-to-Sequence Model)</strong> 一种模型，包含两个部分：处理输入的编码器和生成输出的解码器。它在输入和输出都是序列的应用中很有用，例如机器翻译或语音识别。</p>\n<p><strong>27. 张量 (Tensor)</strong> 一种广义矩阵，用作 TensorFlow 和其他深度学习框架中的基本数据结构，用于表示所有数据：标量是零维张量，向量是一维张量，矩阵是二维张量。</p>\n<p><strong>28. 主干网络 (Backbone Network)</strong> 一种预训练网络，用作另一个特定任务架构的基础，通常用于物体检测等任务中的特征提取，其中来自主干网络的高级特征用于进行预测。</p>\n<p><strong>29. 微调 (Fine-tuning)</strong> 获取预训练深度学习模型（网络已经针对相关任务进行了训练）并在特定于第二个任务的新数据集上继续训练的过程，该数据集的大小可能较小，但可以利用已学习的特征。</p>\n<p><strong>30. 超参数 (Hyperparameters)</strong> 定义网络架构（如层数、每层节点数、学习率）和训练过程的各个方面的参数（如批量大小、轮次数），这些参数在训练之前设置，并直接控制训练算法的行为。</p>\n<p><strong>31. 学习率 (Learning Rate)</strong> 训练算法在损失曲面上的步长大小。较小的学习率可能会使训练更可靠，但也可能使其收敛速度变慢。</p>\n<p><strong>32. Softmax 函数 (Softmax Function)</strong> 这个深度学习术语是在用于多分类的神经网络中的最终激活函数，它通过将每个输出的指数除以所有输出的指数之和，将输出 logits 转换为概率。</p>\n<p><strong>33. 长短期记忆网络 (LSTM)</strong> 一种特殊的 RNN，能够学习长期依赖关系，包括调节信息流的门控。</p>\n<p><strong>34. 梯度消失问题 (Vanishing Gradient Problem)</strong> 训练深度神经网络中的一个挑战是，在反向传播期间，梯度在通过层反向传播时变得越来越小，导致靠近输入层的层学习非常缓慢或停滞。</p>\n<p><strong>35. 梯度爆炸问题 (Exploding Gradient Problem)</strong> 一个问题，其中大的误差梯度累积，并导致在训练期间对神经网络模型权重进行非常大的更新，这可能会导致模型无法收敛甚至发散。</p>\n<p><strong>36. 数据增强 (Data Augmentation)</strong> 用于增加数据量的技术，通过添加已存在数据的略微修改的副本或从现有数据新创建的合成数据，例如在图像处理的上下文中旋转、翻转、缩放或裁剪图像。</p>\n<p><strong>37. 批量大小 (Batch Size)</strong> 在模型训练的一次迭代（单个批次）中使用的训练样本数。</p>\n<p><strong>38. 优化器 (Optimizer)</strong> 用于更改神经网络属性（如权重和学习率）以减少损失的算法或方法。常见的优化器包括 SGD（Stochastic Gradient Descent，随机梯度下降）、Adam 和 RMSprop。</p>\n<p><strong>39. F1 分数 (F1 Score)</strong> 衡量测试准确性的指标，并考虑测试的精度 (precision) 和召回率 (recall) 来计算分数：2 * (精度 * 召回率) / (精度 + 召回率)。当类别分布不均匀时，它特别有用。</p>\n<p><strong>40. 精度 (Precision)</strong> 量化正确正面预测数量的指标。它定义为真阳性 (true positives) 的数量除以真阳性加上假阳性 (false positives) 的数量。</p>\n<p><strong>41. 召回率 (Recall)</strong> 这个深度学习术语也称为灵敏度 (sensitivity) 和召回率 (recall)，它量化了在所有可能做出的正面预测中，正确正面预测的数量。它的计算方法是真阳性的数量除以真阳性加上假阴性 (false negatives) 的数量。</p>\n<p><strong>42. ROC 曲线 (ROC Curve)</strong> 一个图形图，通过绘制真阳性率（召回率）与假阳性率，来说明二元分类器系统在其判别阈值变化时的诊断能力。</p>\n<p><strong>43. 曲线下面积 (AUC)</strong> 在机器学习中，AUC 确定哪些模型最能预测类别。它是 ROC 曲线下的面积；较高的 AUC 表明模型性能更好。</p>\n<p><strong>44. 早停法 (Early Stopping)</strong> 正则化用于避免在使用迭代方法（如梯度下降）训练学习器时发生过拟合。一旦验证数据集上的性能开始下降，训练就会停止。</p>\n<p><strong>45. 特征缩放 (Feature Scaling)</strong> 一种用于标准化数据中自变量或特征范围的方法。数据处理也称为数据归一化，通常在数据预处理阶段执行。</p>\n<p><strong>46. 生成模型 (Generative Model)</strong> 一种统计模型，用于生成数据分布中的所有值，包括观察到的和未观察到的值。深度学习中常见的例子包括生成对抗网络 (GAN) 和变分自编码器 (VAE)。</p>\n<p><strong>47. 判别模型 (Discriminative Model)</strong> 一种对输入数据进行分类的模型；也就是说，它根据训练数据预测给定输入的标签。常见的例子包括大多数监督学习模型，例如逻辑回归和神经网络。</p>\n<p><strong>48. 数据不平衡 (Data Imbalance)</strong> 数据集中每个类别的观察数量分布不均的情况。通常，这对预测建模构成挑战，因为大多数算法都旨在最大化总体准确率。</p>\n<p><strong>49. 降维 (Dimensionality Reduction)</strong> 通过获得一组主要变量来减少考虑中的随机变量的数量。经常使用的技术包括 PCA（Principal Component Analysis，主成分分析）、t-SNE 和自编码器。</p>\n<p><strong>50. 主成分分析 (PCA)</strong> 一种统计程序，它使用正交变换将一组可能相关的变量的观测值转换为一组线性不相关的变量值，称为主成分。</p>\n<p><strong>51. 非线性激活函数 (Nonlinear Activation Functions)</strong> 神经网络中使用的函数，帮助模型学习复杂的数据模式，包括 Sigmoid、Tanh 和 ReLU（Rectified Linear Unit，修正线性单元）函数。</p>\n<p><strong>52. 批量训练 (Batch Training)</strong> 神经网络中的一种训练方法，其中模型权重在处理完整个数据集后更新，而不是在处理单个数据点或小批量后更新。</p>\n<p><strong>53. 随机梯度下降 (SGD)</strong> 一种简单但非常有效的方法，用于拟合凸损失函数（如（线性）支持向量机和逻辑回归）下的线性分类器和回归器。与从整个数据集计算梯度的批量梯度下降不同，SGD 每次仅使用一个数据点更新参数。</p>\n<p><strong>54. 激活图 (Activation Maps)</strong> 深度学习模型（通常在 CNN 中）各个层内特定激活的可视化表示。这些图可以帮助理解输入数据的哪些特征正在激活某些滤波器或神经元。</p>\n<p><strong>55. 零样本学习 (Zero-Shot Learning)</strong> 一个分类问题，其中测试集中的类别在训练期间都未见过；模型必须从已看到的类别推广到未看到的类别。</p>\n<p><strong>56. 一次性学习 (One-Shot Learning)</strong> 一个分类任务，其中学习算法在对新实例进行预测之前，仅给出每个类别的一个示例。</p>\n<p><strong>57. 少样本学习 (Few-Shot Learning)</strong> 一种机器学习方法，其中模型使用极少量标记数据进行训练，通常每个类别一到五个示例。</p>\n<p><strong>58. 对抗样本 (Adversarial Examples)</strong> 稍微修改的输入，旨在欺骗机器学习模型。这些通常用于评估图像分类等任务中模型的鲁棒性。</p>\n<p><strong>59. 胶囊网络 (CapsNets)</strong> 一种深度神经网络，试图通过胶囊（神经元组）捕捉特征之间的空间层次结构，这些胶囊学习识别物体及其在空间中的相对关系，从而可能克服 CNN 的一些局限性。</p>\n<p><strong>60. 注意力层 (Attention Layers)</strong> 常用于序列预测问题的层，帮助模型关注输入序列的特定部分，提高模型记忆长序列而不会丢失数据的能力。</p>\n<p><strong>61. 跳跃连接 (Skip Connections)</strong> 一种用于设计深度神经网络以减轻梯度消失问题的技术，方法是跳过一层或多层。常见于 ResNet 等架构中，其中来自较早层的输出被添加到稍后层的输出中，以帮助保留梯度。</p>\n<p><strong>62. Siamese 网络 (Siamese Networks)</strong> 一种神经网络架构，包含两个或多个相同的子网络。 Siamese 网络非常适合用于查找两个可比较事物之间相似性或关系的任务，例如在人脸验证系统中。</p>\n<p><strong>63. Triplet 损失 (Triplet Loss)</strong> 一种损失函数，用于通过将基线输入与正输入（相似）和负输入（不相似）进行比较来学习有用的嵌入。它确保基线输入比负输入更接近正输入一定的边距。</p>\n<p><strong>64. 自监督学习 (Self-Supervised Learning)</strong> 一种机器学习类型，其中训练数据提供监督，因为输入数据本身用于生成标签。这通常用于标记数据稀缺或昂贵的场景中。</p>\n<p><strong>65. 交叉熵损失 (Cross-Entropy Loss)</strong> 一种损失函数，常用于分类任务。它衡量分类模型的性能，其输出是介于 0 和 1 之间的概率值。交叉熵损失随着预测概率偏离实际标签而增加。</p>\n<p><strong>66. 序列建模 (Sequence Modeling)</strong> 一种深度学习模型，旨在处理顺序数据，例如时间序列或文本。示例包括 RNN、LSTM 和 GRU，它们可以从数据的时间结构中学习。</p>\n<p><strong>67. 空间变换网络 (Spatial Transformer Networks)</strong> 一个 CNN 模块，明确允许在网络内对数据进行空间操作。这可以提高模型的几何不变性，因为它可以空间变换特征图以关注数据中的相关区域。</p>\n<p><strong>68. 教师强制 (Teacher Forcing)</strong> 一种用于训练 RNN 的技术，其中来自先前时间步的目标输出用作当前输入，而不是网络生成的输出。此方法有助于稳定和加速训练。</p>\n<p><strong>69. 神经风格迁移 (Neural Style Transfer)</strong> 一种算法，使用卷积神经网络混合两张图像 —— 一张图像的内容和另一张图像的艺术风格。此过程允许模型学习并将一张图像的风格元素应用于另一张图像的内容。</p>\n<p><strong>70. 标签平滑 (Label Smoothing)</strong> 一种用于降低模型对其预测的信心的技术，通过改变标签的表示方式。标签平滑不是使用硬标签（1 和 0），而是使用略小于 1 和大于 0 的值，通常会导致模型泛化能力的提高。</p>\n<p><strong>71. Lookahead 优化器 (Lookahead Optimizer)</strong> 一种优化器，它通过在当前权重和几个步骤之前的权重之间进行插值来定期更新模型权重，从而帮助稳定优化轨迹。</p>\n<p><strong>72. 集束搜索 (Beam Search)</strong> 一种用于提高序列建模中预测质量的算法，尤其是在自然语言处理中。它不是在每一步预测最可能的下一步，而是跟踪 k 个最可能的序列路径。</p>\n<p><strong>73. 知识蒸馏 (Knowledge Distillation)</strong> 一种方法，其中训练一个较小的模型（称为 “学生”）来重现更大的预训练模型（或 “教师”）的行为。这项技术允许在资源受限的环境中部署强大的模型。</p>\n<p><strong>74. T-SNE (t-Distributed Stochastic Neighbor Embedding，t - 分布随机邻域嵌入)</strong> 一种用于降维的机器学习算法，特别适用于高维数据集的可视化。它将数据点的亲和力转换为概率，并最小化低维嵌入的联合概率与高维数据的联合概率之间的 Kullback-Leibler 散度。</p>\n<p><strong>75. 梯度裁剪 (Gradient Clipping)</strong> 一种用于对抗训练期间梯度爆炸问题的技术。它涉及在反向传播期间裁剪梯度，以防止它们超过定义的阈值。</p>\n<p><strong>76. 元学习 (Meta-Learning)</strong> 有时称为 “学习如何学习”，它涉及在各种学习任务上训练模型，使其可以使用少量训练样本来解决新的学习任务。</p>\n<p><strong>77. 神经架构搜索 (NAS)</strong> 机器学习的一个领域，专注于自动化人工神经网络的设计。 NAS 使用强化学习、进化算法或基于梯度的方法来为给定任务生成最佳架构。</p>\n<p><strong>78. 量化 (Quantization)</strong> 减少神经网络中表示数字的位数的过程。量化减小了模型大小并提高了推理速度，使其适用于在计算资源有限的移动设备上部署。</p>\n<p><strong>79. 自注意力 (Self-Attention) (续)</strong> Transformer 架构已证明在许多 NLP 任务中有效，因为它使模型能够权衡句子或文档中不同单词相对于彼此的重要性。</p>\n<p><strong>80. Transformer 模型 (Transformer Models)</strong> 一种神经网络架构，它避开了循环，而是完全依赖自注意力机制来绘制输入和输出之间的全局依赖关系，这在翻译和文本生成等任务中具有革命性意义。</p>\n<p><strong>81. BERT (Bidirectional Encoder Representations from Transformers，来自 Transformers 的双向编码器表示)</strong> 谷歌的一种方法，通过在所有层中联合调节左右上下文，从无标签文本中预训练深度双向表示。因此，预训练的 BERT 模型只需一个额外的输出层即可进行微调，从而为各种任务创建最先进的模型。</p>\n<p><strong>82. 分词 (Tokenization)</strong> 在 NLP 中，分词是将一段文本分割成更小的单元（称为标记），标记可以是单词、字符或子词。这通常是处理要由神经网络使用的文本的第一步之一。</p>\n<p><strong>83. 词嵌入 (Word Embeddings)</strong> 一种词表示类型，允许含义相似的词具有相似的表示。它们是 NLP 中的一组语言建模和特征学习技术，其中词汇表中的单词或短语被映射到实数向量。</p>\n<p><strong>84. 位置编码 (Positional Encoding)</strong> 在 Transformer 模型架构中，由于自注意力机制本身不捕捉序列顺序，因此将位置编码添加到输入嵌入中，以提供有关序列中标记的相对或绝对位置的一些信息。</p>\n<p><strong>85. 图神经网络 (GNNs)</strong> 一种直接在图结构上运行的神经网络。这些网络通过图中节点之间的消息传递来捕获图的依赖关系。</p>\n<p><strong>86. 强化学习 (Reinforcement Learning)</strong> 一种机器学习类型，其中智能体通过执行某些动作并接收奖励或惩罚来学习在环境中表现。这种学习方法基于游戏化的概念，特别用于游戏和自动驾驶汽车等场景。</p>\n<p><strong>87. 经验回放 (Experience Replay)</strong> 在强化学习中，经验回放涉及存储智能体在每个时间步的经验，而不是在状态 - 动作对发生时运行 Q 学习。稍后，可以在批次中将这些经验重放给智能体，打破时间相关性并平滑数据分布的变化。</p>\n<p><strong>88. 课程学习 (Curriculum Learning)</strong> 一种训练策略，从学习任务的较容易的方面或复杂任务的早期阶段开始，并逐渐增加难度级别。这种方法的灵感来自人类的学习方式，可以加快收敛速度并提高性能。</p>\n<p><strong>89. 模型剪枝 (Model Pruning)</strong> 从现有神经网络中算法地移除参数的过程，而不会显着影响其性能。剪枝有助于降低部署模型的计算成本，还可以减小模型大小。</p>\n<p><strong>90. 持续学习 (Continuous Learning)</strong> 这个深度学习术语也称为终身学习 (lifelong learning)；这是一种机器学习形式，其中算法不断学习和适应新数据，而不会忘记以前的知识。这对于在动态环境中运行的应用程序至关重要。</p>\n<p><strong>91. 偏差 - 方差权衡 (Bias-Variance Tradeoff)</strong> 监督学习中的一个基本问题是，增加偏差会减少方差，反之亦然。偏差 - 方差权衡是一个属性，它定义了任何模型在给定训练集上可达到的准确率的限制。</p>\n<p><strong>92. 灾难性遗忘 (Catastrophic Forgetting)</strong> 一种现象，其中神经网络在学习新信息后会忘记先前学习的信息，这是持续学习中的一个重大挑战。</p>\n<p><strong>93. 多模态学习 (Multimodal Learning)</strong> 这种方法涉及在来自多个模态的数据上训练模型，例如包含图像和文本的数据集。它有助于通过结合来自不同来源的信息来学习更丰富的表示。</p>\n<p><strong>94. 异常检测 (Anomaly Detection)</strong> 识别罕见的项目、事件或观察结果，这些项目、事件或观察结果因与大多数数据显着不同而引起怀疑。这在欺诈检测、网络安全和故障检测中特别有用。</p>\n<p><strong>95. 分布外检测 (Out-of-Distribution Detection)</strong> 识别在某些方面与训练分布不同的数据样本。这在自动驾驶等安全关键型应用中至关重要，在这些应用中，模型必须识别和处理它尚未明确训练过的情况。</p>\n<p><strong>96. 卷积 (Convolution)</strong> 卷积神经网络内部工作中使用的一种数学运算。它涉及取一个小数矩阵（内核）与一个较大矩阵的每个部分的点积，以产生一个新矩阵，有效地过滤原始矩阵。</p>\n<p><strong>97. 池化 (Pooling) (续)</strong> 具体而言，CNN 中的池化层降低了每个特征图的维度，同时保留了最重要的信息，这有助于检测对尺度和方向变化不变的特征，并减少计算负载。常见的池化类型包括最大池化和平均池化，它们分别取输入区域的最大值和平均值</p>\n<p><strong>98. 空洞卷积 (Dilated Convolutions)</strong> 这个深度学习术语也称为 atrous 卷积。这些卷积涉及在卷积层的内核中插入空格，有效地扩大其视野，而无需增加参数数量或计算量。这对于需要理解更大上下文的任务（例如语义图像分割）很有用。</p>\n<p><strong>99. 序列到序列学习 (Sequence-to-Sequence Learning)</strong> 深度学习中的一个过程，其中模型被训练为将来自一个域（例如，英语句子）的序列转换为另一个域（例如，法语句子）的序列。这种模型架构通常涉及编码器 - 解码器框架，并且是机器翻译和语音识别应用程序的核心。</p>\n<p><strong>100. 注意力机制 (Attention Mechanisms)</strong> 关于这个概念的进一步阐述，注意力机制允许模型根据需要关注输入序列的不同部分以生成输出序列，从而提高模型处理文本摘要和机器翻译等任务中长序列的能力。多头注意力 (multi-headed attention) 等变体提供了从不同表示子空间的不同位置关注信息的能力。</p>\n",
            "tags": [
                "Artificial-Intelligence",
                "Deep-Learning",
                "深度学习"
            ]
        },
        {
            "id": "https://lzq-cv.github.io/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/",
            "url": "https://lzq-cv.github.io/PyTorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA/",
            "title": "PyTorch深度学习框架搭建",
            "date_published": "2025-09-29T13:15:52.000Z",
            "content_html": "<h1 id=\"pytorch深度学习环境搭建\"><a class=\"anchor\" href=\"#pytorch深度学习环境搭建\">#</a> PyTorch 深度学习环境搭建</h1>\n<h3 id=\"一python\"><a class=\"anchor\" href=\"#一python\">#</a> 一，Python</h3>\n<p>官方网站：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucHl0aG9uLm9yZy9kb3dubG9hZHMvd2luZG93cy8=\">python.org/downloads/windows/</span></p>\n<p>安装好后查看版本</p>\n<p><figure class=\"highlight cmd\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 推荐<span class=\"number\">3</span>.<span class=\"number\">10</span></span><br><span class=\"line\">python -V or python --version</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"二cuda-toolkit\"><a class=\"anchor\" href=\"#二cuda-toolkit\">#</a> 二，CUDA Toolkit</h3>\n<p>官方网站：[<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubnZpZGlhLmNvbS9jdWRhLXRvb2xraXQtYXJjaGl2ZQ==\">CUDA Toolkit Archive | NVIDIA Developer</span>](<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubnZpZGlhLmNvbS9jdWRhLWRvd25sb2Fkcw==\">https://developer.nvidia.com/cuda-downloads</span>)</p>\n<p>先查看当前显卡驱动支持的最高 CUDA 版本</p>\n<p><img data-src=\"https://lzq-cv.oss-cn-shanghai.aliyuncs.com/GPU.png\" alt=\"\" /></p>\n<p>然后，安装 CUDA，这里最高支持 12.3，推荐安装 CUDA11.8 稳定版本</p>\n<p>CUDA 安装好后，查看 CUDA 安装的版本</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nvcc --version</span><br></pre></td></tr></table></figure></p>\n<p><img data-src=\"https://lzq-cv.oss-cn-shanghai.aliyuncs.com/CUDA.png\" alt=\"\" /></p>\n<h3 id=\"三anaconda\"><a class=\"anchor\" href=\"#三anaconda\">#</a> 三，Anaconda</h3>\n<p>官方网站：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYW5hY29uZGEuY29tL2Rvd25sb2Fk\">https://www.anaconda.com/download</span></p>\n<p>选择与 python 版本对应的版本安装</p>\n<p>安装好后查看当前版本</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">conda --version</span><br></pre></td></tr></table></figure></p>\n<p><img data-src=\"https://lzq-cv.oss-cn-shanghai.aliyuncs.com/anaconda.png\" alt=\"\" /></p>\n<h3 id=\"四cudnn\"><a class=\"anchor\" href=\"#四cudnn\">#</a> 四，cuDNN</h3>\n<p>官方网站：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9kZXZlbG9wZXIubnZpZGlhLmNvbS9jdWRubi1kb3dubG9hZHM=\">https://developer.nvidia.com/cudnn-downloads</span></p>\n<p>解压缩后拖入，如图</p>\n<p><img data-src=\"https://lzq-cv.oss-cn-shanghai.aliyuncs.com/cuDNN.png\" alt=\"\" /></p>\n<h3 id=\"五pytorch\"><a class=\"anchor\" href=\"#五pytorch\">#</a> 五，PyTorch</h3>\n<p>官方网站：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9weXRvcmNoLm9yZy9nZXQtc3RhcnRlZC9wcmV2aW91cy12ZXJzaW9ucy8=\">Previous PyTorch Versions</span></p>\n<p><img data-src=\"https://lzq-cv.oss-cn-shanghai.aliyuncs.com/pytorch.png\" alt=\"\" /></p>\n<h3 id=\"六pycharm\"><a class=\"anchor\" href=\"#六pycharm\">#</a> 六，Pycharm</h3>\n<p>官方网站：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuamV0YnJhaW5zLmNvbS96aC1jbi9weWNoYXJtL2Rvd25sb2FkL290aGVyLmh0bWw=\">https://www.jetbrains.com/zh-cn/pycharm/download/other.html</span></p>\n<p><img data-src=\"https://lzq-cv.oss-cn-shanghai.aliyuncs.com/6.png\" alt=\"\" /></p>\n<h3 id=\"七测试代码\"><a class=\"anchor\" href=\"#七测试代码\">#</a> 七，测试代码</h3>\n<p><img data-src=\"https://lzq-cv.oss-cn-shanghai.aliyuncs.com/PyTorchGPU.png\" alt=\"\" /></p>\n",
            "tags": [
                "Artificial-Intelligence",
                "Deep-Learning",
                "PyTorch"
            ]
        },
        {
            "id": "https://lzq-cv.github.io/2D%E8%A7%86%E8%A7%89%E7%9A%84%E4%B8%BB%E6%B5%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/",
            "url": "https://lzq-cv.github.io/2D%E8%A7%86%E8%A7%89%E7%9A%84%E4%B8%BB%E6%B5%81%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/",
            "title": "2D视觉的主流应用场景",
            "date_published": "2025-09-27T01:45:29.000Z",
            "content_html": "<h3 id=\"2d视觉主流应用场景与技术栈详解\"><a class=\"anchor\" href=\"#2d视觉主流应用场景与技术栈详解\">#</a> 2D 视觉主流应用场景与技术栈详解</h3>\n<p>主流的 2D 视觉应用分为以下几个大类。</p>\n<hr />\n<h4 id=\"1-安防与监控\"><a class=\"anchor\" href=\"#1-安防与监控\">#</a> 1. 安防与监控</h4>\n<p>这是 2D 视觉最经典、最广泛的应用领域。</p>\n<ul>\n<li>\n<p><strong>核心任务：</strong></p>\n<ul>\n<li><strong>人脸识别与身份验证：</strong> 门禁系统、手机解锁、公共安全排查。</li>\n<li><strong>人体检测与行为分析：</strong> 入侵检测、人群密度估计、徘徊检测、跌倒检测、打架斗殴识别。</li>\n<li><strong>车辆识别与交通监控：</strong> 车牌识别、车辆违章检测（闯红灯、压线）、交通流量分析。</li>\n<li><strong>物体遗留 / 消失检测：</strong> 在机场、火车站等场景检测可疑包裹。</li>\n</ul>\n</li>\n<li>\n<p><strong>主流技术栈：</strong></p>\n<ul>\n<li><strong>检测模型：</strong>\n<ul>\n<li><strong>YOLO 系列 (v5, v8, v9)：</strong> 绝对是该领域的首选，因其极高的速度和良好的精度，非常适合实时视频流分析。</li>\n<li><strong>SSD, RetinaNet：</strong> 也是常用的单阶段检测器。</li>\n</ul>\n</li>\n<li><strong>识别 / 分类模型：</strong>\n<ul>\n<li><strong>人脸识别：</strong> 使用专门的人脸检测（如 MTCNN、RetinaFace）加上人脸识别模型（如<strong> ArcFace</strong>、FaceNet、CosFace）。这些模型将人脸图像映射为一个高维特征向量，通过比对向量相似度进行身份识别。</li>\n<li><strong>行为识别：</strong> 相对复杂，通常需要处理视频序列。技术包括：\n<ul>\n<li><strong>3D CNN：</strong> 直接处理视频片段。</li>\n<li><strong>CNN + RNN/LSTM：</strong> 用 CNN 提取每一帧的特征，再用 RNN/LSTM 学习时序关系。</li>\n<li><strong>基于 Transformer 的方法：</strong> 如 TimeSformer，更好地捕捉长距离依赖。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>关键工具：</strong>\n<ul>\n<li><strong>OpenCV：</strong> 用于视频流捕获、图像预处理、绘制检测框、车牌识别中的字符分割等。</li>\n<li><strong>深度学习框架：</strong> PyTorch（研究和新模型部署主流）、TensorFlow（现有系统较多）。</li>\n<li><strong>部署工具：</strong> <strong>NVIDIA TensorRT</strong>（用于在 NVIDIA GPU 上极致加速推理）、<strong>OpenVINO</strong>（用于 Intel CPU/GPU 等硬件）。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>实际考量：</strong></p>\n<ul>\n<li><strong>实时性要求极高：</strong> 模型必须轻量化，通常需要在边缘设备（如 Jetson Nano、华为 Atlas）上运行。</li>\n<li><strong>光照、角度变化大：</strong> 要求模型有很强的鲁棒性，数据增强（如随机亮度、对比度变化）非常重要。</li>\n<li><strong>隐私问题：</strong> 需要遵循相关法律法规。</li>\n</ul>\n</li>\n</ul>\n<hr />\n<h4 id=\"2-工业质检与自动化\"><a class=\"anchor\" href=\"#2-工业质检与自动化\">#</a> 2. 工业质检与自动化</h4>\n<p>这是 2D 视觉在工业界创造巨大价值的核心应用。</p>\n<ul>\n<li>\n<p><strong>核心任务：</strong></p>\n<ul>\n<li><strong>缺陷检测：</strong> 检测产品表面的划痕、凹陷、污点、毛刺等。</li>\n<li><strong>分类与分拣：</strong> 根据外观对产品进行合格 / 不合格分类，或按不同品类分拣。</li>\n<li><strong>定位与引导：</strong> 精确识别零件的位置和姿态，引导机械臂进行抓取、装配。</li>\n<li><strong>OCR 读取：</strong> 读取产品上的生产日期、批次号、序列号。</li>\n</ul>\n</li>\n<li>\n<p><strong>主流技术栈：</strong></p>\n<ul>\n<li><strong>缺陷检测：</strong>\n<ul>\n<li><strong>传统方法：</strong> 在规则、可控的照明环境下，传统算法依然非常有效且快速。例如，使用<strong> Blob 分析</strong>（找连通域）、<strong>模板匹配</strong>、<strong>形态学操作</strong>、<strong>频域滤波</strong>（如傅里叶变换找周期性缺陷）等。<strong>Halcon</strong> 和 <strong>VisionPro</strong> 是商业软件中的佼佼者。</li>\n<li><strong>深度学习方法：</strong> 对于复杂、不规则的缺陷，深度学习是更好的选择。\n<ul>\n<li><strong>语义分割：</strong> <strong>U-Net</strong> 及其变体是主流，可以像素级精确地定位缺陷区域。</li>\n<li><strong>生成式方法：</strong> 使用<strong>自编码器</strong> 或<strong>生成对抗网络</strong> 学习正常样本的特征，然后通过重建误差来检测异常（缺陷被视为异常）。这种方法特别适合<strong>缺陷样本稀少</strong>的场景。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><strong>定位与 OCR：</strong>\n<ul>\n<li><strong>定位：</strong> 通常使用<strong>模板匹配</strong>（传统）或训练一个目标检测模型（如 YOLO）来预测物体的边界框或角点。</li>\n<li><strong>OCR：</strong> 通用场景可用 <strong>PaddleOCR</strong>、<strong>Tesseract</strong>。工业场景中字符通常规则且背景固定，也可以自己训练 CRNN（CNN+RNN+CTC）等模型，精度更高。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>实际考量：</strong></p>\n<ul>\n<li><strong>环境可控：</strong> 光照、相机位置、背景都是固定的，这是与安防场景的最大不同。</li>\n<li><strong>精度要求极高：</strong> 漏检和误检的成本很高，模型评估指标（如 mAP, IoU）要求严格。</li>\n<li><strong>速度要求：</strong> 需跟上生产线节奏，但通常不如安防实时性要求高。</li>\n<li><strong>数据瓶颈：</strong> 缺陷样本难以收集，小样本学习和无监督 / 半监督方法备受关注。</li>\n</ul>\n</li>\n</ul>\n<hr />\n<h4 id=\"3-医疗影像分析\"><a class=\"anchor\" href=\"#3-医疗影像分析\">#</a> 3. 医疗影像分析</h4>\n<p>2D 视觉在辅助诊断方面发挥着越来越重要的作用。</p>\n<ul>\n<li>\n<p><strong>核心任务：</strong></p>\n<ul>\n<li><strong>病灶检测与分割：</strong> 在 X 光、CT 切片、MRI、病理切片中定位和勾画肿瘤、结节、出血点等。</li>\n<li><strong>分类与筛查：</strong> 判断影像是否异常（如胸片筛查肺结核、眼底照片筛查糖尿病视网膜病变）。</li>\n<li><strong>量化分析：</strong> 测量肿瘤大小、体积变化等。</li>\n</ul>\n</li>\n<li>\n<p><strong>主流技术栈：</strong></p>\n<ul>\n<li><strong>核心架构：</strong>\n<ul>\n<li><strong>U-Net：</strong> 在医学图像分割领域是<strong>事实上的标准</strong>，因其能有效利用有限的标注数据并产生精确的分割结果。</li>\n<li><strong>DeepLab 系列、nnUNet：</strong> nnUNet 是一个强大的自动化框架，在众多医学分割挑战中取得优异成绩。</li>\n</ul>\n</li>\n<li><strong>检测与分类：</strong>\n<ul>\n<li>使用在 ImageNet 上预训练的<strong> CNN 骨干网络</strong>（如 ResNet, DenseNet, EfficientNet）进行迁移学习，作为分类或检测模型的特征提取器。</li>\n</ul>\n</li>\n<li><strong>关键挑战与技术：</strong>\n<ul>\n<li><strong>数据量小、标注成本极高：</strong> 迁移学习、<strong>半监督学习</strong>（如 FixMatch）、<strong>自监督学习</strong>（先在无标签数据上预训练）是关键。</li>\n<li><strong>模型可解释性：</strong> 医生需要知道模型为何做出判断。<strong>类激活图</strong> 等技术可以高亮显示图像中对决策最重要的区域。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>实际考量：</strong></p>\n<ul>\n<li><strong>伦理与监管：</strong> 模型需通过严格的临床验证，并符合医疗器械监管标准（如 FDA、NMPA）。</li>\n<li><strong>模型必须是 “辅助” 角色：</strong> 最终诊断权在医生，系统需要提供置信度和可解释性。</li>\n</ul>\n</li>\n</ul>\n<hr />\n<h4 id=\"4-自动驾驶与智能交通\"><a class=\"anchor\" href=\"#4-自动驾驶与智能交通\">#</a> 4. 自动驾驶与智能交通</h4>\n<p>虽然自动驾驶重度依赖 3D 感知，但其视觉子系统大量使用 2D 技术。</p>\n<ul>\n<li>\n<p><strong>核心任务：</strong></p>\n<ul>\n<li><strong>2D 目标检测：</strong> 实时检测车辆、行人、骑行者、交通标志、交通灯。</li>\n<li><strong>车道线检测：</strong> 识别车辆可行驶区域的车道线。</li>\n<li><strong>可行驶区域分割：</strong> 分割出道路区域。</li>\n<li><strong>多目标跟踪：</strong> 跟踪周围动态目标的运动轨迹。</li>\n</ul>\n</li>\n<li>\n<p><strong>主流技术栈：</strong></p>\n<ul>\n<li><strong>检测模型：</strong>\n<ul>\n<li><strong>YOLO 系列、SSD：</strong> 对实时性要求极高，单阶段检测器是主流。</li>\n<li><strong>CNN + FPN：</strong> 特征金字塔网络用于有效检测不同尺度的目标。</li>\n</ul>\n</li>\n<li><strong>分割模型：</strong>\n<ul>\n<li><strong>基于编码器 - 解码器的实时分割网络：</strong> 如<strong> DeepLabv3+</strong>（配合轻量级主干网）、<strong>BiSeNet</strong>（专为实时语义分割设计）。</li>\n</ul>\n</li>\n<li><strong>跟踪算法：</strong>\n<ul>\n<li><strong>SORT/DeepSORT：</strong> 经典的跟踪范式，使用卡尔曼滤波预测运动，并用外观特征（由小型 CNN 提取）进行数据关联。</li>\n</ul>\n</li>\n<li><strong>数据集：</strong>\n<ul>\n<li><strong>KITTI, BDD100K, Cityscapes</strong> 是公开的权威基准。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>实际考量：</strong></p>\n<ul>\n<li><strong>安全性第一：</strong> 任何错误都可能导致严重后果，要求模型有极高的召回率（尽可能不漏检）。</li>\n<li><strong>复杂场景：</strong> 天气变化、遮挡、光照变化剧烈，对模型的鲁棒性是巨大挑战。</li>\n<li><strong>系统集成：</strong> 2D 视觉结果通常需要与激光雷达、高精地图等 3D 信息进行融合，做出最终决策。</li>\n</ul>\n</li>\n</ul>\n<hr />\n<h4 id=\"5-零售与电商\"><a class=\"anchor\" href=\"#5-零售与电商\">#</a> 5. 零售与电商</h4>\n<ul>\n<li>\n<p><strong>核心任务：</strong></p>\n<ul>\n<li><strong>智能货柜：</strong> 利用摄像头识别用户拿取的商品，实现自动结算。</li>\n<li><strong>商品识别与搜索：</strong> 拍照搜同款、商品自动分类。</li>\n<li><strong>顾客行为分析：</strong> 分析客流、热力图、顾客动线、停留时间。</li>\n</ul>\n</li>\n<li>\n<p><strong>主流技术栈：</strong></p>\n<ul>\n<li><strong>商品识别：</strong>\n<ul>\n<li><strong>检测 + 识别：</strong> 先用目标检测（YOLO）框出商品，再用分类网络（ResNet）识别具体品类。对于细粒度识别（不同型号的鞋子），需要更精细的网络设计。</li>\n<li><strong>度量学习：</strong> 类似人脸识别，将商品图像映射为特征向量，通过计算向量相似度来搜索同类商品。<strong>Triplet Loss</strong> 是常用方法。</li>\n</ul>\n</li>\n<li><strong>客流统计：</strong>\n<ul>\n<li>使用<strong>人体检测</strong>（YOLO）和<strong>跟踪</strong>（DeepSORT）来统计进出人数和轨迹。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>实际考量：</strong></p>\n<ul>\n<li><strong>SKU 繁多且更新快：</strong> 模型需要能够快速适应新商品，<strong>小样本学习</strong>和<strong>在线学习</strong>能力很重要。</li>\n<li><strong>对精度要求高：</strong> 直接关系到结算金额，不能出错。</li>\n</ul>\n</li>\n</ul>\n<hr />\n<h4 id=\"6-互联网娱乐与aigc\"><a class=\"anchor\" href=\"#6-互联网娱乐与aigc\">#</a> 6. 互联网娱乐与 AIGC</h4>\n<p>这是近年来最火爆的方向。</p>\n<ul>\n<li>\n<p><strong>核心任务：</strong></p>\n<ul>\n<li><strong>图像分类与打标：</strong> 为相册、社交媒体图片自动添加标签。</li>\n<li><strong>人脸特效与美颜：</strong> 美颜相机、贴纸、年龄变化、表情迁移。</li>\n<li><strong>图像生成与编辑：</strong> 文生图、图生图、风格迁移、老照片修复、图像超分辨率。</li>\n</ul>\n</li>\n<li>\n<p><strong>主流技术栈：</strong></p>\n<ul>\n<li><strong>传统图像处理：</strong> OpenCV 中的滤波、形变、色彩调整等是美颜算法的基础。</li>\n<li><strong>人脸相关：</strong>\n<ul>\n<li><strong>人脸关键点检测：</strong> 用于精准贴纸、美颜（瘦脸、大眼）。</li>\n<li><strong>人脸分割：</strong> 用于虚化背景、染发试色。</li>\n<li><strong>GAN / 扩散模型：</strong> 用于生成虚拟形象、换脸等。</li>\n</ul>\n</li>\n<li><strong>生成式 AI：</strong>\n<ul>\n<li><strong>扩散模型：</strong> <strong>Stable Diffusion</strong> 是当前绝对的主流，用于文生图、图生图、inpainting（局部重绘）等。</li>\n<li><strong>GAN：</strong> StyleGAN 系列在高质量人脸生成上仍有应用。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>实际考量：</strong></p>\n<ul>\n<li><strong>追求视觉效果和创造性。</strong></li>\n<li><strong>对计算资源要求高：</strong> 尤其是扩散模型，推理需要强大的 GPU。</li>\n<li><strong>伦理问题：</strong> 深度伪造技术带来的滥用风险。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">应用领域</th>\n<th style=\"text-align:left\">核心任务</th>\n<th style=\"text-align:left\">主流技术栈（模型 / 算法）</th>\n<th style=\"text-align:left\">关键工具 / 框架</th>\n<th style=\"text-align:left\">特殊考量</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>安防与监控</strong></td>\n<td style=\"text-align:left\">人脸识别、行为分析、车辆检测</td>\n<td style=\"text-align:left\">YOLO, SSD, ArcFace, DeepSORT, 3D CNN/LSTM</td>\n<td style=\"text-align:left\">OpenCV, PyTorch, TensorRT, OpenVINO</td>\n<td style=\"text-align:left\">实时性、边缘计算、鲁棒性、隐私</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>工业质检</strong></td>\n<td style=\"text-align:left\">缺陷检测、定位、OCR</td>\n<td style=\"text-align:left\">U-Net, AE/VAE（异常检测）, YOLO, 模板匹配，Blob 分析</td>\n<td style=\"text-align:left\">Halcon, OpenCV, PyTorch/TensorFlow</td>\n<td style=\"text-align:left\">高精度、环境可控、小样本缺陷</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>医疗影像</strong></td>\n<td style=\"text-align:left\">病灶分割、分类筛查</td>\n<td style=\"text-align:left\">U-Net, nnUNet, ResNet/DenseNet（迁移学习）</td>\n<td style=\"text-align:left\">PyTorch, TensorFlow, 类激活图</td>\n<td style=\"text-align:left\">数据稀缺、高标注成本、可解释性、法规</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>自动驾驶</strong></td>\n<td style=\"text-align:left\">2D 检测、车道线 / 可行驶区域分割</td>\n<td style=\"text-align:left\">YOLO, DeepLabv3+, BiSeNet, DeepSORT</td>\n<td style=\"text-align:left\">PyTorch, TensorRT, CUDA</td>\n<td style=\"text-align:left\">安全性、极端鲁棒性、多传感器融合</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>零售电商</strong></td>\n<td style=\"text-align:left\">商品识别、客流分析</td>\n<td style=\"text-align:left\">YOLO, ResNet（度量学习）, DeepSORT</td>\n<td style=\"text-align:left\">PyTorch, TensorFlow, OpenCV</td>\n<td style=\"text-align:left\">SKU 更新快、细粒度识别、结算精度</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>互联网娱乐</strong></td>\n<td style=\"text-align:left\">美颜、图像生成、标签推荐</td>\n<td style=\"text-align:left\">人脸关键点模型，Stable Diffusion, StyleGAN</td>\n<td style=\"text-align:left\">OpenCV, PyTorch, Diffusers 库</td>\n<td style=\"text-align:left\">计算资源、创意效果、伦理风险</td>\n</tr>\n</tbody>\n</table>\n",
            "tags": [
                "Computer-Vision",
                "Opencv",
                "CV"
            ]
        },
        {
            "id": "https://lzq-cv.github.io/2D%E8%A7%86%E8%A7%89%E5%92%8C3D%E8%A7%86%E8%A7%89%E7%9A%84%E4%B8%BB%E6%B5%81%E6%8A%80%E6%9C%AF%E6%A0%88/",
            "url": "https://lzq-cv.github.io/2D%E8%A7%86%E8%A7%89%E5%92%8C3D%E8%A7%86%E8%A7%89%E7%9A%84%E4%B8%BB%E6%B5%81%E6%8A%80%E6%9C%AF%E6%A0%88/",
            "title": "2D视觉和3D视觉的主流技术栈",
            "date_published": "2025-09-27T01:38:14.000Z",
            "content_html": "<p>计算机视觉（CV）领域的主流技术栈，2D 视觉和 3D 视觉的技术、应用与区别。</p>\n<h3 id=\"一-计算机视觉技术栈总览\"><a class=\"anchor\" href=\"#一-计算机视觉技术栈总览\">#</a> 一、 计算机视觉技术栈总览</h3>\n<p>计算机视觉的技术栈可以大致分为三个层次，从底层的基础工具到顶层的具体应用：</p>\n<ol>\n<li>\n<p><strong>底层基础层：</strong></p>\n<ul>\n<li><strong>编程语言：</strong> <strong>Python</strong> 是绝对的主流，因其丰富的库和社区生态。C++ 在需要高性能、低延迟的场合（如嵌入式、自动驾驶）中不可或缺。</li>\n<li><strong>数学基础：</strong> 线性代数、微积分、概率论、数值分析是理解算法的基石。</li>\n<li><strong>硬件：</strong> <strong>GPU（NVIDIA）</strong> 是训练和部署深度学习模型的核心。专用的 AI 芯片（如 Google TPU, NVIDIA Jetson, Intel Movidius）也在边缘计算中扮演重要角色。</li>\n</ul>\n</li>\n<li>\n<p><strong>核心工具与框架层：</strong></p>\n<ul>\n<li><strong>深度学习框架：</strong>\n<ul>\n<li><strong>PyTorch：</strong> 当前学术界和工业界的首选，以其动态图和简洁的 API 深受研究人员喜爱。</li>\n<li><strong>TensorFlow：</strong> 由 Google 支持，在工业界部署（尤其是使用 TensorFlow Lite, TensorRT 时）仍有强大优势。Keras 是其高级 API，易于上手。</li>\n</ul>\n</li>\n<li><strong>传统计算机视觉库：</strong>\n<ul>\n<li><strong>OpenCV：</strong> 计算机视觉的 “瑞士军刀”，提供了从图像 / 视频读写、预处理、几何变换、特征提取到目标检测（传统方法）等海量功能，是必备基础库。</li>\n</ul>\n</li>\n<li><strong>3D 视觉专用库：</strong>\n<ul>\n<li><strong>Open3D：</strong> 一个现代化的 3D 数据处理库，支持点云、网格的可视化、配准、重建等。</li>\n<li><strong>PCL：</strong> 点云库，功能非常强大但接口相对陈旧，在 C++ 项目中广泛使用。</li>\n<li><strong>VTK, ITK：</strong> 主要用于科学可视化和医学图像处理。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>模型与算法层：</strong></p>\n<ul>\n<li>这是技术栈的核心，下面将分 2D 和 3D 详细展开。</li>\n</ul>\n</li>\n</ol>\n<hr />\n<h3 id=\"二-2d-计算机视觉\"><a class=\"anchor\" href=\"#二-2d-计算机视觉\">#</a> 二、 2D 计算机视觉</h3>\n<p>2D 视觉处理的是像素矩阵，即我们常见的 RGB 或灰度图像。</p>\n<h4 id=\"核心任务与技术\"><a class=\"anchor\" href=\"#核心任务与技术\">#</a> 核心任务与技术</h4>\n<ol>\n<li>\n<p><strong>图像分类：</strong> 判断图像中包含什么物体。</p>\n<ul>\n<li><strong>核心技术：</strong> 卷积神经网络。</li>\n<li><strong>经典模型：</strong>\n<ul>\n<li><strong>开创者：</strong> AlexNet (2012)</li>\n<li><strong>深度代表：</strong> VGGNet</li>\n<li><strong>革新者：</strong> GoogLeNet (Inception 模块), ResNet (残差连接，解决了深层网络梯度消失问题)，这些模型至今仍是强大的<strong>骨干网络</strong>。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>目标检测：</strong> 找出图像中所有感兴趣物体的位置（用边界框表示）和类别。</p>\n<ul>\n<li><strong>两阶段检测器（精度高，速度慢）：</strong>\n<ul>\n<li><strong>R-CNN 系列：</strong> R-CNN -&gt; Fast R-CNN -&gt; <strong>Faster R-CNN</strong>。先产生候选区域，再对区域进行分类和微调。</li>\n</ul>\n</li>\n<li><strong>单阶段检测器（速度快，精度可媲美两阶段）：</strong>\n<ul>\n<li><strong>YOLO 系列：</strong> 特别是 <strong>v3, v5, v8, v9</strong>，将检测视为单一的回归问题，速度极快，是实时应用的首选。</li>\n<li><strong>SSD：</strong> 另一个经典的单阶段检测器。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>图像分割：</strong> 对每个像素进行分类，为每个物体生成精确的轮廓。</p>\n<ul>\n<li><strong>语义分割：</strong> 只区分类别，不区分个体（例如，图中所有的 “人” 都是同一类）。\n<ul>\n<li><strong>核心架构：</strong> <strong>编码器 - 解码器</strong>结构。编码器（如 ResNet）提取特征，解码器（如<strong> U-Net</strong>）恢复空间维度并进行像素级预测。<strong>DeepLab</strong> 系列（使用空洞卷积）也是主流。</li>\n</ul>\n</li>\n<li><strong>实例分割：</strong> 既区分类别，也区分不同的个体（例如，区分出第一个人，第二个人）。\n<ul>\n<li><strong>经典模型：</strong> <strong>Mask R-CNN</strong>，是在 Faster R-CNN 基础上的扩展，增加了一个分支来预测每个目标的二值掩码。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>关键点检测：</strong> 检测物体上具有特定意义的点。</p>\n<ul>\n<li><strong>应用：</strong> 人脸关键点（眼、鼻、嘴）、人体姿态估计（关节点的位置）。</li>\n<li><strong>典型方法：</strong> 通常建模为热图回归问题，即预测每个关键点可能出现的概率分布图。<strong>HRNet</strong> 是当前人体姿态估计的 SOTA 方法之一。</li>\n</ul>\n</li>\n<li>\n<p><strong>图像生成与编辑：</strong></p>\n<ul>\n<li><strong>生成对抗网络（GANs）：</strong> 如 StyleGAN 系列，用于生成逼真的人脸、艺术品等。</li>\n<li><strong>扩散模型：</strong> 如 Stable Diffusion、DALL-E，已成为图像生成的新范式，生成质量更高、更可控。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"2d视觉技术栈总结\"><a class=\"anchor\" href=\"#2d视觉技术栈总结\">#</a> 2D 视觉技术栈总结</h4>\n<ul>\n<li><strong>输入：</strong> RGB 图像（H x W x 3）。</li>\n<li><strong>核心网络：</strong> <strong>卷积神经网络</strong>。</li>\n<li><strong>主要框架：</strong> PyTorch / TensorFlow + OpenCV。</li>\n<li><strong>趋势：</strong> Vision Transformer (ViT) 正在挑战 CNN 的统治地位，显示出强大的性能。轻量化模型（如 MobileNet, ShuffleNet）用于移动端和嵌入式设备是重要方向。</li>\n</ul>\n<hr />\n<h3 id=\"三-3d-计算机视觉\"><a class=\"anchor\" href=\"#三-3d-计算机视觉\">#</a> 三、 3D 计算机视觉</h3>\n<p>3D 视觉旨在理解和重建三维世界的信息，其输入和数据表示形式远比 2D 丰富。</p>\n<h4 id=\"数据表示形式\"><a class=\"anchor\" href=\"#数据表示形式\">#</a> 数据表示形式</h4>\n<ol>\n<li><strong>深度图：</strong> 每个像素的值代表该点到相机的距离。通常由 RGB-D 相机（如 Kinect, RealSense）或立体视觉直接获得。</li>\n<li><strong>点云：</strong> 一组三维空间中的点（x, y, z）的集合，可以包含颜色、法向量等信息。是激光雷达的直接输出。</li>\n<li><strong>体素网格：</strong> 将 3D 空间离散化为一个个小立方体（类似于 2D 的像素），是 3D 卷积的自然延伸，但内存消耗大。</li>\n<li><strong>网格：</strong> 由顶点、边和面（通常是三角面片）构成的曲面，是 3D 建模和渲染的通用格式。</li>\n<li><strong>多视图图像：</strong> 从不同视角拍摄的同一物体的多张 2D 图像，可通过运动恢复结构技术生成 3D 模型。</li>\n</ol>\n<h4 id=\"核心任务与技术-2\"><a class=\"anchor\" href=\"#核心任务与技术-2\">#</a> 核心任务与技术</h4>\n<ol>\n<li>\n<p><strong>3D 重建：</strong> 从一组 2D 图像或深度传感器数据中恢复物体的 3D 模型。</p>\n<ul>\n<li><strong>运动恢复结构：</strong> 从多视角图像中计算相机姿态和稀疏的 3D 点云。</li>\n<li><strong>多视图立体视觉：</strong> 在 SfM 的基础上，生成稠密的 3D 点云或网格。</li>\n<li><strong>深度学习方法：</strong> 如 MVSNet 等，利用神经网络直接从多视图图像中学习生成深度图或点云。</li>\n</ul>\n</li>\n<li>\n<p><strong>点云处理：</strong></p>\n<ul>\n<li><strong>点云分类与分割：</strong> 对点云中的每个点或整个点云进行分类。\n<ul>\n<li><strong>开创性工作：</strong> <strong>PointNet</strong> / <strong>PointNet++</strong>，直接处理无序的点云集合。</li>\n<li><strong>后续发展：</strong> 基于图卷积、稀疏卷积（如<strong> Minkowski Engine</strong>）的方法能更好地捕捉局部特征。</li>\n</ul>\n</li>\n<li><strong>点云配准：</strong> 将不同视角扫描的点云对齐到同一个坐标系下。经典算法有 ICP，深度学习如 PointNetLK, DCP 等。</li>\n</ul>\n</li>\n<li>\n<p><strong>3D 目标检测：</strong></p>\n<ul>\n<li><strong>基于 LiDAR：</strong> 直接在点云中检测 3D bounding box（包含中心点、长宽高、朝向）。<strong>VoxelNet</strong>、<strong>PointPillars</strong>、<strong>SECOND</strong> 是经典且高效的模型。</li>\n<li><strong>基于视觉：</strong> 仅使用单目或双目 RGB 图像来估计 3D 框，难度更大，是当前研究热点。</li>\n<li><strong>多模态融合：</strong> 结合相机（RGB）和激光雷达（点云）的信息，提升检测精度，是自动驾驶领域的核心。</li>\n</ul>\n</li>\n<li>\n<p><strong>SLAM：</strong> 即时定位与地图构建。</p>\n<ul>\n<li>机器人在未知环境中移动，同时估计自身位置并构建环境地图。</li>\n<li><strong>视觉 SLAM：</strong> 使用单目、双目或 RGB-D 相机作为主要传感器。ORB-SLAM 系列是里程碑式的工作。</li>\n<li><strong>激光 SLAM：</strong> 使用激光雷达，如 LOAM、Cartographer，通常更精确。</li>\n</ul>\n</li>\n<li>\n<p><strong>神经辐射场：</strong> 一种革命性的 3D 场景表示和渲染技术。</p>\n<ul>\n<li><strong>核心思想（NeRF）：</strong> 用一个神经网络将空间位置和观看视角映射为颜色和密度，从而可以从任意视角生成逼真的新视图。衍生出了大量快速、动态的 NeRF 变体。</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"3d视觉技术栈总结\"><a class=\"anchor\" href=\"#3d视觉技术栈总结\">#</a> 3D 视觉技术栈总结</h4>\n<ul>\n<li><strong>输入：</strong> 点云、深度图、多视图图像等。</li>\n<li><strong>核心挑战：</strong> 数据的<strong>无序性</strong>（点云）、<strong>稀疏性</strong>、<strong>非结构化</strong>。</li>\n<li><strong>核心技术：</strong>\n<ul>\n<li><strong>传统几何方法：</strong> 多视图几何、光束法平差、ICP。</li>\n<li><strong>深度学习方法：</strong> 针对 3D 数据特化的网络（PointNet 系列、3D 稀疏卷积、Transformer）。</li>\n</ul>\n</li>\n<li><strong>主要框架：</strong> PyTorch / TensorFlow + Open3D / PCL。</li>\n</ul>\n<hr />\n<h3 id=\"四-2d视觉-vs-3d视觉-对比总结\"><a class=\"anchor\" href=\"#四-2d视觉-vs-3d视觉-对比总结\">#</a> 四、 2D 视觉 vs. 3D 视觉 对比总结</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">特性</th>\n<th style=\"text-align:left\">2D 计算机视觉</th>\n<th style=\"text-align:left\">3D 计算机视觉</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>数据输入</strong></td>\n<td style=\"text-align:left\">二维像素矩阵（RGB / 灰度图）</td>\n<td style=\"text-align:left\">点云、深度图、多视图图像、网格等</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>信息维度</strong></td>\n<td style=\"text-align:left\">缺少深度和真实的几何信息</td>\n<td style=\"text-align:left\">包含丰富的三维几何和空间关系信息</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>核心任务</strong></td>\n<td style=\"text-align:left\">分类、检测、分割（在像素层面）</td>\n<td style=\"text-align:left\">3D 重建、3D 检测、SLAM、点云处理</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>核心技术</strong></td>\n<td style=\"text-align:left\">卷积神经网络（CNN），Transformer</td>\n<td style=\"text-align:left\">多视图几何、点云网络（PointNet）、3D 卷积、神经辐射场（NeRF）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>应用场景</strong></td>\n<td style=\"text-align:left\">图像检索、照片美化、安防监控、图像内容审核</td>\n<td style=\"text-align:left\"><strong>自动驾驶</strong>、<strong>机器人导航</strong>、<strong>AR/VR</strong>、无人机、工业三维测量</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>数据获取</strong></td>\n<td style=\"text-align:left\">简单、廉价（普通摄像头）</td>\n<td style=\"text-align:left\">相对复杂、昂贵（RGB-D 相机、激光雷达）或需要计算（SfM）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>挑战</strong></td>\n<td style=\"text-align:left\">光照变化、遮挡、视角变化、类内差异</td>\n<td style=\"text-align:left\">数据稀疏、噪声大、计算复杂度高、标注成本极高</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"五-融合与未来趋势\"><a class=\"anchor\" href=\"#五-融合与未来趋势\">#</a> 五、 融合与未来趋势</h3>\n<p>未来的发展方向绝不是 2D 和 3D 的割裂，而是<strong>深度融合</strong>：</p>\n<ul>\n<li><strong>多模态学习：</strong> 将 2D 图像的丰富纹理和语义信息与 3D 数据的精确几何结构相结合。例如，在自动驾驶中，用 2D 检测的结果辅助 3D 检测，或者用 3D 信息为 2D 分割提供空间上下文。</li>\n<li><strong>2D 引导的 3D 理解：</strong> 利用在大型 2D 图像数据集（如 ImageNet）上预训练的模型，通过知识蒸馏或迁移学习来提升 3D 模型的性能，解决 3D 数据稀缺的问题。</li>\n<li><strong>AIGC 在 3D 中的应用：</strong> 利用扩散模型等生成式 AI 技术，从文本或单张图像直接生成高质量的 3D 模型（如 TripoSR、Shap-E 等），这将极大降低 3D 内容创作的门槛。</li>\n</ul>\n",
            "tags": [
                "Computer-Vision",
                "Opencv",
                "CV"
            ]
        },
        {
            "id": "https://lzq-cv.github.io/LAMP%E5%92%8CLNMP%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E5%8C%BA%E5%88%AB/",
            "url": "https://lzq-cv.github.io/LAMP%E5%92%8CLNMP%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E6%9E%84%E7%9A%84%E5%8C%BA%E5%88%AB/",
            "title": "LAMP和LNMP服务器架构的区别",
            "date_published": "2025-09-27T00:51:01.000Z",
            "content_html": "<p>LAMP 和 LNMP 是两种最流行的传统网站服务器架构组合。它们的核心区别在于 <strong>Web 服务器</strong> 的不同。</p>\n<ul>\n<li><strong>LAMP</strong>: Linux + <strong>A</strong>pache + MySQL/MariaDB + PHP/Python/Perl</li>\n<li><strong>LNMP</strong>: Linux + <strong>N</strong>ginx + MySQL/MariaDB + PHP/Python/Perl\n<ul>\n<li>有时也被称为 <strong>LEMP</strong>（因为 Nginx 读作 “engine-x”，所以取首字母 “E”）。<strong>LNMP 和 LEMP 指的是同一个架构</strong>。</li>\n</ul>\n</li>\n</ul>\n<hr />\n<h3 id=\"一-核心组件对比\"><a class=\"anchor\" href=\"#一-核心组件对比\">#</a> 一、核心组件对比</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">组件</th>\n<th style=\"text-align:left\">LAMP 栈</th>\n<th style=\"text-align:left\">LNMP 栈</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>操作系统 (L)</strong></td>\n<td style=\"text-align:left\"><strong>L</strong>inux</td>\n<td style=\"text-align:left\"><strong>L</strong>inux</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Web 服务器</strong></td>\n<td style=\"text-align:left\"><strong>A</strong>pache HTTP Server</td>\n<td style=\"text-align:left\"><strong>N</strong>ginx</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>数据库 (M)</strong></td>\n<td style=\"text-align:left\"><strong>M</strong>ySQL / MariaDB</td>\n<td style=\"text-align:left\"><strong>M</strong>ySQL / MariaDB</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>编程语言 (P)</strong></td>\n<td style=\"text-align:left\"><strong>P</strong>HP, Python, Perl（PHP 最经典）</td>\n<td style=\"text-align:left\"><strong>P</strong>HP, Python, Perl（PHP 最经典）</td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h3 id=\"二-核心区别apache-vs-nginx\"><a class=\"anchor\" href=\"#二-核心区别apache-vs-nginx\">#</a> 二、核心区别：Apache vs. Nginx</h3>\n<p>这是两个技术栈最根本的差异，其他区别都源于此。</p>\n<h4 id=\"apachelamp-的核心\"><a class=\"anchor\" href=\"#apachelamp-的核心\">#</a> Apache（LAMP 的核心）</h4>\n<ul>\n<li>\n<p><strong>工作模型</strong>：</p>\n<ul>\n<li>传统上采用 <strong>多进程 / 多线程预生成（MPM Prefork/Worker）模型</strong>。每个并发连接都会由一个独立的进程或线程处理。</li>\n<li><strong>优点</strong>： 模型简单稳定，与各种 PHP 模块兼容性好。</li>\n<li><strong>缺点</strong>： 当面对成千上万的并发连接时，创建和管理大量进程 / 线程会消耗大量的内存和 CPU 资源，成为性能瓶颈。</li>\n</ul>\n</li>\n<li>\n<p><strong>配置方式</strong>：</p>\n<ul>\n<li>支持通过目录下的 <strong>.htaccess</strong> 文件进行分布式配置。这意味着可以在网站根目录下的任何文件夹里放置一个 <code>.htaccess</code>  文件来重写主配置（如 URL 重写、访问控制等）。</li>\n<li><strong>优点</strong>： 对共享主机环境极其友好，用户无需重启 Apache 即可修改配置，非常灵活。</li>\n<li><strong>缺点</strong>： 带来性能损失，因为 Apache 需要遍历目录树来查找和解析 <code>.htaccess</code>  文件。</li>\n</ul>\n</li>\n<li>\n<p><strong>特性</strong>：</p>\n<ul>\n<li>模块化程度极高，功能全面，拥有一个巨大的模块生态。任何需求（如认证、缓存、重写等）几乎都能找到对应模块。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"nginxlnmp-的核心\"><a class=\"anchor\" href=\"#nginxlnmp-的核心\">#</a> Nginx（LNMP 的核心）</h4>\n<ul>\n<li>\n<p><strong>工作模型</strong>：</p>\n<ul>\n<li>采用 <strong>事件驱动、异步非阻塞</strong> 的架构。它使用一个（或少量）工作进程，每个进程可以高效地处理数千个并发连接。</li>\n<li><strong>优点</strong>： 资源占用（尤其是内存）极低，在高并发场景下性能远超 Apache，特别适合静态内容处理、反向代理和负载均衡。</li>\n<li><strong>缺点</strong>： 架构相对复杂。</li>\n</ul>\n</li>\n<li>\n<p><strong>配置方式</strong>：</p>\n<ul>\n<li><strong>不支持  <code>.htaccess</code> </strong>。所有配置都必须集中在主配置文件或 <code>/etc/nginx/sites-available/</code>  这样的虚拟主机文件中，然后重载 Nginx 服务才能生效。</li>\n<li><strong>优点</strong>： 配置更集中，性能更高，因为不需要遍历目录查找配置文件。</li>\n<li><strong>缺点</strong>： 对共享主机用户不友好，修改配置需要服务器权限和重载服务。</li>\n</ul>\n</li>\n<li>\n<p><strong>处理 PHP 的方式（关键区别）</strong>：</p>\n<ul>\n<li>Nginx <strong>自身不能直接处理 PHP 等动态语言</strong>。它需要一个额外的处理器（如 PHP-FPM）。</li>\n<li>当用户请求一个 PHP 文件时，Nginx 会将请求<strong>反向代理</strong>给 PHP-FPM 进程进行处理，PHP-FPM 处理完毕后将结果返回给 Nginx，再由 Nginx 发送给用户。</li>\n<li>这种 “各司其职” 的架构反而更清晰、高效。</li>\n</ul>\n</li>\n</ul>\n<hr />\n<h3 id=\"三-详细对比表格\"><a class=\"anchor\" href=\"#三-详细对比表格\">#</a> 三、详细对比表格</h3>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">特性</th>\n<th style=\"text-align:left\">LAMP (Apache)</th>\n<th style=\"text-align:left\">LNMP (Nginx)</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>性能</strong></td>\n<td style=\"text-align:left\">处理动态内容稳定，但<strong>高并发下性能较差</strong></td>\n<td style=\"text-align:left\"><strong>高并发性能极佳</strong>，尤其擅长处理静态文件</td>\n<td style=\"text-align:left\">Nginx 的事件驱动模型在并发性能上具有先天优势</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>资源占用</strong></td>\n<td style=\"text-align:left\">相对较高（进程 / 线程模型）</td>\n<td style=\"text-align:left\"><strong>非常低</strong>（事件驱动模型）</td>\n<td style=\"text-align:left\">对于内存有限的 VPS 服务器，LNMP 优势明显</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>配置灵活性</strong></td>\n<td style=\"text-align:left\"><strong>高</strong>（支持.htaccess）</td>\n<td style=\"text-align:left\">较低（需修改主配置并重载）</td>\n<td style=\"text-align:left\">对于需要频繁修改.htaccess 的 CMS（如 WordPress），LAMP 更方便</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>静态内容处理</strong></td>\n<td style=\"text-align:left\">良好</td>\n<td style=\"text-align:left\"><strong>极快</strong></td>\n<td style=\"text-align:left\">Nginx 设计之初就是为解决 C10K 问题，静态文件响应速度一流</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>动态内容处理</strong></td>\n<td style=\"text-align:left\">直接通过模块（如 mod_php）处理</td>\n<td style=\"text-align:left\">需通过 PHP-FPM 等外部处理器</td>\n<td style=\"text-align:left\">LAMP 方式更 “一体化”，LNMP 方式更 “解耦”</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>安全性</strong></td>\n<td style=\"text-align:left\">良好，历史悠久，问题暴露充分</td>\n<td style=\"text-align:left\">良好，因设计简单，攻击面相对较小</td>\n<td style=\"text-align:left\">两者都非常安全，安全更多取决于运维人员的技术</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>学习曲线</strong></td>\n<td style=\"text-align:left\">较为简单，资料丰富</td>\n<td style=\"text-align:left\">配置语法独特，需要理解其工作流程</td>\n<td style=\"text-align:left\">有 Apache 基础的人需要适应 Nginx 的配置思维</td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>适用场景</strong></td>\n<td style=\"text-align:left\">传统虚拟主机、共享主机、中小型网站、需要.htaccess 功能的项目</td>\n<td style=\"text-align:left\"><strong>高并发网站</strong>、API 服务器、静态资源服务器、反向代理 / 负载均衡器、VPS / 云服务器</td>\n<td style=\"text-align:left\"></td>\n</tr>\n</tbody>\n</table>\n<hr />\n<h3 id=\"四-如何选择\"><a class=\"anchor\" href=\"#四-如何选择\">#</a> 四、如何选择？</h3>\n<ol>\n<li>\n<p><strong>选择 LAMP 的情况：</strong></p>\n<ul>\n<li>你使用的是传统的共享虚拟主机（cPanel 等面板通常内置 Apache）。</li>\n<li>你的网站严重依赖 <code>.htaccess</code>  文件（例如，使用了复杂的 WordPress 重写规则插件）。</li>\n<li>项目规模不大，并发用户数不高，更追求配置的便捷性。</li>\n<li>你对 Apache 非常熟悉。</li>\n</ul>\n</li>\n<li>\n<p><strong>选择 LNMP 的情况：</strong></p>\n<ul>\n<li>使用的是 VPS、独立服务器或云服务器，拥有 root 权限。</li>\n<li>网站<strong>预期有高并发访问量</strong>（如新闻门户、电商平台等）。</li>\n<li>服务器资源（内存）有限，需要尽可能优化性能。</li>\n<li>需要将服务器同时用作 Web 服务器和反向代理 / 负载均衡器。</li>\n<li>网站有大量静态资源（图片、CSS、JS）需要快速响应。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"总结\"><a class=\"anchor\" href=\"#总结\">#</a> 总结</h3>\n<p>简单来说，可以这样理解：</p>\n<ul>\n<li><strong>LAMP</strong> 像一个<strong>全能型选手</strong>，开箱即用，配置灵活，非常成熟稳定，但在极限压力下（高并发）会显得吃力。</li>\n<li><strong>LNMP</strong> 像一个<strong>专项冠军</strong>，它在高并发和低资源消耗方面表现卓越，尤其适合现代 Web 架构，但需要更多的配置工作，灵活性稍差。</li>\n</ul>\n<p>如今，随着 Nginx 的普及，<strong>LNMP 架构已经成为大多数新项目和追求性能的运维人员的首选</strong>。甚至出现了一种混合架构：用 Nginx 作为前端反向代理处理静态请求，并将动态请求转发给后端的 Apache，结合两者的优点。但对于绝大多数场景，直接使用完整的 LNMP 栈是更优的选择。</p>\n",
            "tags": [
                "服务器"
            ]
        },
        {
            "id": "https://lzq-cv.github.io/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89%E7%A1%AC%E4%BB%B6%E5%A6%82%E4%BD%95%E9%80%89%E5%9E%8B/",
            "url": "https://lzq-cv.github.io/%E6%9C%BA%E5%99%A8%E8%A7%86%E8%A7%89%E7%A1%AC%E4%BB%B6%E5%A6%82%E4%BD%95%E9%80%89%E5%9E%8B/",
            "title": "机器视觉硬件如何选型",
            "date_published": "2025-09-26T10:08:56.000Z",
            "content_html": "<h1 id=\"机器视觉硬件选型指南\"><a class=\"anchor\" href=\"#机器视觉硬件选型指南\">#</a> 机器视觉硬件选型指南</h1>\n<h2 id=\"概述\"><a class=\"anchor\" href=\"#概述\">#</a> 概述</h2>\n<p>机器视觉硬件选型是为特定的机器视觉应用需求，从众多硬件组件中科学地挑选出最合适的相机、镜头、光源、处理器及其他辅助设备的过程。其核心目标是构建一套能稳定、精确、高效地完成指定视觉任务（如检测、测量、识别、定位等）的硬件系统。</p>\n<hr />\n<h2 id=\"核心组件选型\"><a class=\"anchor\" href=\"#核心组件选型\">#</a> 核心组件选型</h2>\n<h3 id=\"相机\"><a class=\"anchor\" href=\"#相机\">#</a> 相机</h3>\n<h4 id=\"类型\"><a class=\"anchor\" href=\"#类型\">#</a> 类型</h4>\n<ul>\n<li><strong>面阵相机</strong>：最常用，适用于静止或连续运动的物体成像（如传送带）\n<ul>\n<li>选型重点：分辨率、帧率、传感器尺寸、像元尺寸、快门类型</li>\n</ul>\n</li>\n<li><strong>线阵相机</strong>：适用于高速连续运动物体或需要超高分辨率的场景（如卷材检测、印刷检测）\n<ul>\n<li>选型重点：行频、分辨率（线数）、传感器长度、像元尺寸、行曝光时间控制</li>\n</ul>\n</li>\n<li><strong>区域扫描相机</strong>：即面阵相机</li>\n<li><strong>3D 相机</strong>：用于获取深度信息（如体积测量、引导抓取）\n<ul>\n<li>技术包括：双目立体视觉、结构光、激光三角测量、飞行时间</li>\n<li>选型重点：精度、量程、点云密度、抗环境光能力、速度</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"传感器技术\"><a class=\"anchor\" href=\"#传感器技术\">#</a> 传感器技术</h4>\n<ul>\n<li><strong>CMOS</strong>：主流技术，性价比高，速度快，功耗低，抗拖影能力好，支持全局快门或卷帘快门</li>\n<li><strong>CCD</strong>：成像质量（尤其是低照度、均一性）通常优于 CMOS，但速度慢、功耗高、成本高、易产生拖影，逐渐被 CMOS 取代</li>\n</ul>\n<h4 id=\"分辨率\"><a class=\"anchor\" href=\"#分辨率\">#</a> 分辨率</h4>\n<ul>\n<li>根据检测精度要求计算： <code>所需最小像素数 = (待测特征尺寸 / 检测精度要求) × 2</code> （满足奈奎斯特采样定理）</li>\n<li>示例：检测 0.1mm 缺陷，精度要求 0.05mm，则单个特征至少需要  <code>(0.1 / 0.05) × 2 = 4</code>  个像素覆盖</li>\n<li>避免过度追求高分辨率：增加成本、降低帧率、增大数据量</li>\n</ul>\n<h4 id=\"帧率\"><a class=\"anchor\" href=\"#帧率\">#</a> 帧率</h4>\n<ul>\n<li>计算公式： <code>所需最小帧率 = (物体移动速度 / 相机视野内允许的最大物体位移)</code></li>\n<li>高帧率需求：高速运动物体检测、需要捕捉快速瞬变过程</li>\n</ul>\n<h4 id=\"快门类型\"><a class=\"anchor\" href=\"#快门类型\">#</a> 快门类型</h4>\n<ul>\n<li><strong>全局快门</strong>：所有像素同时曝光，适合拍摄运动物体，无运动模糊（工业应用首选）</li>\n<li><strong>卷帘快门</strong>：像素逐行曝光，拍摄运动物体时会产生果冻效应</li>\n</ul>\n<h4 id=\"接口\"><a class=\"anchor\" href=\"#接口\">#</a> 接口</h4>\n<ul>\n<li><strong>GigE Vision</strong>：主流，性价比高，线缆长（可达 100m）</li>\n<li><strong>USB3 Vision</strong>：即插即用方便，带宽高，但线缆短（&lt;5m）</li>\n<li><strong>Camera Link</strong>：传统高速接口，需要专用采集卡</li>\n<li><strong>CoaXPress</strong>：新兴高速接口，带宽极高，线缆长，抗干扰强</li>\n<li><strong>MIPI</strong>：主要用于嵌入式系统</li>\n</ul>\n<h4 id=\"色彩\"><a class=\"anchor\" href=\"#色彩\">#</a> 色彩</h4>\n<ul>\n<li><strong>黑白</strong>：灵敏度高，分辨率高，速度快，成本低</li>\n<li><strong>彩色</strong>：用于需要区分颜色的应用，需注意拜耳滤镜带来的分辨率和灵敏度损失</li>\n</ul>\n<h4 id=\"其他特性\"><a class=\"anchor\" href=\"#其他特性\">#</a> 其他特性</h4>\n<ul>\n<li>传感器尺寸：影响视野和景深</li>\n<li>像元尺寸：影响分辨率和灵敏度</li>\n<li>灵敏度 / 量子效率：在低光照条件下尤其重要</li>\n<li>动态范围：反映相机同时捕捉亮部和暗部细节的能力</li>\n</ul>\n<hr />\n<h3 id=\"镜头\"><a class=\"anchor\" href=\"#镜头\">#</a> 镜头</h3>\n<h4 id=\"焦距\"><a class=\"anchor\" href=\"#焦距\">#</a> 焦距</h4>\n<ul>\n<li>计算公式： <code>焦距 f ≈ (传感器尺寸 × 工作距离) / 视野</code></li>\n<li>根据视野和工作距离计算所需焦距范围</li>\n</ul>\n<h4 id=\"光圈\"><a class=\"anchor\" href=\"#光圈\">#</a> 光圈</h4>\n<ul>\n<li><strong>大光圈</strong>：进光量大，适合低照度环境，但景深小</li>\n<li><strong>小光圈</strong>：景深大，适合有一定厚度或不在同一平面的物体</li>\n<li>F 值越小，光圈越大</li>\n</ul>\n<h4 id=\"接口-2\"><a class=\"anchor\" href=\"#接口-2\">#</a> 接口</h4>\n<ul>\n<li>必须与相机接口匹配</li>\n<li>常见工业接口：C 口（最普遍）、CS 口、F 口、M42、M58 等</li>\n</ul>\n<h4 id=\"分辨率-2\"><a class=\"anchor\" href=\"#分辨率-2\">#</a> 分辨率</h4>\n<ul>\n<li>镜头的解析能力必须匹配相机的分辨率</li>\n<li>镜头分辨率用 MTF 曲线表示，应略高于传感器需求</li>\n</ul>\n<h4 id=\"畸变\"><a class=\"anchor\" href=\"#畸变\">#</a> 畸变</h4>\n<ul>\n<li>高精度测量应用需选择低畸变镜头（&lt;0.1%）</li>\n</ul>\n<h4 id=\"类型-2\"><a class=\"anchor\" href=\"#类型-2\">#</a> 类型</h4>\n<ul>\n<li><strong>定焦镜头</strong>：最常见，性价比高</li>\n<li><strong>变焦镜头</strong>：焦距可调，灵活性高</li>\n<li><strong>远心镜头</strong>：精密测量必备，消除透视误差</li>\n<li><strong>微距镜头</strong>：专为高倍率、短工作距离设计</li>\n<li><strong>液态镜头</strong>：通过电压控制焦距，实现毫秒级自动对焦</li>\n</ul>\n<hr />\n<h3 id=\"光源\"><a class=\"anchor\" href=\"#光源\">#</a> 光源</h3>\n<h4 id=\"目的\"><a class=\"anchor\" href=\"#目的\">#</a> 目的</h4>\n<p>突出被测特征，抑制背景干扰，提高对比度，保证成像稳定性和一致性</p>\n<h4 id=\"类型led光源为主\"><a class=\"anchor\" href=\"#类型led光源为主\">#</a> 类型（LED 光源为主）</h4>\n<ul>\n<li><strong>环形光</strong>：通用性好，提供漫射光，减少阴影</li>\n<li><strong>条形光</strong>：用于长条状物体或需要定向照明</li>\n<li><strong>背光源</strong>：轮廓检测、透明物体杂质检测</li>\n<li><strong>同轴光</strong>：检测光滑平面上的划痕、凹凸</li>\n<li><strong>穹顶光</strong>：提供均匀漫射光，消除反光</li>\n<li><strong>点光源 / 线光源</strong>：用于特殊角度照明</li>\n<li><strong>结构光</strong>：投射特定图案用于 3D 测量</li>\n</ul>\n<h4 id=\"颜色选择\"><a class=\"anchor\" href=\"#颜色选择\">#</a> 颜色选择</h4>\n<ul>\n<li>选择能最大化目标特征与背景对比度的颜色</li>\n<li>互补色原理：物体颜色与光源颜色互为补色时对比度最高</li>\n<li>单色光常能提高对比度</li>\n</ul>\n<h4 id=\"照明方式\"><a class=\"anchor\" href=\"#照明方式\">#</a> 照明方式</h4>\n<ul>\n<li><strong>明场照明</strong>：光线反射进入镜头</li>\n<li><strong>暗场照明</strong>：光线以低角度照射，用于检测划痕、凹凸、纹理</li>\n<li><strong>透射照明</strong>：即背光</li>\n</ul>\n<hr />\n<h3 id=\"图像采集卡\"><a class=\"anchor\" href=\"#图像采集卡\">#</a> 图像采集卡</h3>\n<h4 id=\"作用\"><a class=\"anchor\" href=\"#作用\">#</a> 作用</h4>\n<p>对于需要 Camera Link 或 CoaXPress 接口的相机，采集卡负责将高速图像数据传输到 PC 内存</p>\n<h4 id=\"选型要点\"><a class=\"anchor\" href=\"#选型要点\">#</a> 选型要点</h4>\n<ul>\n<li>接口类型和带宽必须匹配相机</li>\n<li>通道数：支持单相机或多相机</li>\n<li>内存：板载内存大小影响传输稳定性</li>\n<li>I/O 支持：触发输入 / 输出、编码器输入等</li>\n<li>软件兼容性</li>\n</ul>\n<hr />\n<h3 id=\"处理器工控机\"><a class=\"anchor\" href=\"#处理器工控机\">#</a> 处理器 / 工控机</h3>\n<h4 id=\"cpu\"><a class=\"anchor\" href=\"#cpu\">#</a> CPU</h4>\n<p>选择性能强劲的多核处理器（Intel Core i5/i7/i9, Xeon）</p>\n<h4 id=\"内存\"><a class=\"anchor\" href=\"#内存\">#</a> 内存</h4>\n<ul>\n<li>推荐 16GB 起步</li>\n<li>复杂应用需要 32GB 甚至更多</li>\n</ul>\n<h4 id=\"存储\"><a class=\"anchor\" href=\"#存储\">#</a> 存储</h4>\n<p>SSD 固态硬盘（NVMe 更好）用于快速启动和存储</p>\n<h4 id=\"gpu\"><a class=\"anchor\" href=\"#gpu\">#</a> GPU</h4>\n<p>对于深度学习应用、复杂的 3D 点云处理非常关键</p>\n<h4 id=\"操作系统\"><a class=\"anchor\" href=\"#操作系统\">#</a> 操作系统</h4>\n<ul>\n<li>Windows 10/11 IoT Enterprise LTSC（工业推荐）</li>\n<li>Linux（开源，定制性强）</li>\n</ul>\n<hr />\n<h3 id=\"其他硬件\"><a class=\"anchor\" href=\"#其他硬件\">#</a> 其他硬件</h3>\n<h4 id=\"光学滤镜\"><a class=\"anchor\" href=\"#光学滤镜\">#</a> 光学滤镜</h4>\n<ul>\n<li><strong>偏振片</strong>：消除眩光、反光</li>\n<li><strong>带通 / 窄带滤光片</strong>：抑制环境光干扰</li>\n<li><strong>中性密度滤光片</strong>：防止过曝</li>\n</ul>\n<h4 id=\"传感器编码器\"><a class=\"anchor\" href=\"#传感器编码器\">#</a> 传感器 / 编码器</h4>\n<p>用于提供物体位置信号触发相机 / 光源</p>\n<h4 id=\"io模块\"><a class=\"anchor\" href=\"#io模块\">#</a> I/O 模块</h4>\n<p>连接 PLC、传感器、执行器等自动化设备</p>\n<h4 id=\"防护罩机械支架\"><a class=\"anchor\" href=\"#防护罩机械支架\">#</a> 防护罩 / 机械支架</h4>\n<p>保护设备，确保安装稳固</p>\n<hr />\n<h2 id=\"关键选型考量因素\"><a class=\"anchor\" href=\"#关键选型考量因素\">#</a> 关键选型考量因素</h2>\n<h3 id=\"应用需求\"><a class=\"anchor\" href=\"#应用需求\">#</a> 应用需求</h3>\n<ul>\n<li>检测目标（尺寸、缺陷、有无、定位等）</li>\n<li>精度要求（亚像素级？微米级？毫米级？）</li>\n<li>速度要求（产线节拍）</li>\n<li>视野大小和工作距离</li>\n<li>被测物体特性（材质、颜色、表面反光性等）</li>\n<li>环境条件（温度、湿度、粉尘、振动等）</li>\n</ul>\n<h3 id=\"性能指标\"><a class=\"anchor\" href=\"#性能指标\">#</a> 性能指标</h3>\n<p>基于应用需求推导出的具体参数：分辨率、帧率、景深、曝光时间等</p>\n<h3 id=\"成本预算\"><a class=\"anchor\" href=\"#成本预算\">#</a> 成本预算</h3>\n<p>在满足性能要求的前提下，平衡各组件成本</p>\n<h3 id=\"系统集成与兼容性\"><a class=\"anchor\" href=\"#系统集成与兼容性\">#</a> 系统集成与兼容性</h3>\n<ul>\n<li>各组件之间的兼容性</li>\n<li>与现有自动化设备的通信接口</li>\n<li>视觉软件的选择</li>\n</ul>\n<h3 id=\"可靠性与维护\"><a class=\"anchor\" href=\"#可靠性与维护\">#</a> 可靠性与维护</h3>\n<p>工业环境要求硬件具有高可靠性和长寿命</p>\n<h3 id=\"供应商支持与服务\"><a class=\"anchor\" href=\"#供应商支持与服务\">#</a> 供应商支持与服务</h3>\n<p>良好的技术支持和售后服务至关重要</p>\n<hr />\n<h2 id=\"选型流程建议\"><a class=\"anchor\" href=\"#选型流程建议\">#</a> 选型流程建议</h2>\n<ol>\n<li><strong>明确定义需求</strong>：详细列出所有应用要求、目标和约束条件</li>\n<li><strong>计算核心参数</strong>：分辨率、帧率、工作距离和景深</li>\n<li><strong>初步选择相机</strong>：基于分辨率、帧率、接口等筛选</li>\n<li><strong>选择镜头</strong>：基于相机传感器尺寸、工作距离、视野计算焦距</li>\n<li><strong>设计光源方案</strong>：确定光源类型、颜色、照明方式</li>\n<li><strong>选择处理器 / 工控机</strong>：根据算法复杂度、图像数据量选择配置</li>\n<li><strong>选择其他组件</strong>：采集卡、光源控制器、滤镜等</li>\n<li><strong>验证与测试</strong>：搭建原型系统进行实际测试</li>\n<li><strong>评估供应商与成本</strong>：综合评估技术指标、价格、服务等</li>\n<li><strong>最终决策与采购</strong></li>\n</ol>\n<hr />\n<h2 id=\"选型案例手机屏缺陷检测\"><a class=\"anchor\" href=\"#选型案例手机屏缺陷检测\">#</a> 选型案例：手机屏缺陷检测</h2>\n<h3 id=\"需求\"><a class=\"anchor\" href=\"#需求\">#</a> 需求</h3>\n<ul>\n<li>检测 6 英寸手机屏表面划痕、脏污、亮点 / 暗点</li>\n<li>精度要求：0.05mm 缺陷</li>\n<li>产线速度：1 秒 / 片</li>\n</ul>\n<h3 id=\"计算\"><a class=\"anchor\" href=\"#计算\">#</a> 计算</h3>\n<ul>\n<li><strong>视野</strong>：略大于屏幕尺寸，约 180mm × 90mm</li>\n<li><strong>精度</strong>：0.05mm 缺陷 → 至少需要 4 个像素覆盖\n<ul>\n<li>单方向最小像素数 = (180mm / 0.05mm) × 2 = 7200 像素</li>\n<li>选择 800 万像素以上相机</li>\n</ul>\n</li>\n<li><strong>帧率</strong>：检测时间 &lt; 1 秒，选择 30fps 相机较宽裕</li>\n</ul>\n<h3 id=\"选型方案\"><a class=\"anchor\" href=\"#选型方案\">#</a> 选型方案</h3>\n<ul>\n<li><strong>相机</strong>：高分辨率面阵 CMOS 全局快门相机，800 万像素以上，GigE 或 USB3 接口，黑白</li>\n<li><strong>镜头</strong>：远心镜头或低畸变定焦镜头，高分辨率</li>\n<li><strong>光源</strong>：同轴光或低角度条形光（暗场）突出划痕、脏污</li>\n<li><strong>处理器</strong>：性能较强的工控机（i7 CPU, 32GB RAM），配备 GPU</li>\n<li><strong>其他</strong>：编码器触发相机抓拍，I/O 与 PLC 通信</li>\n</ul>\n",
            "tags": [
                "机器视觉"
            ]
        },
        {
            "id": "https://lzq-cv.github.io/%E4%BD%BF%E7%94%A8PICGO-%E9%98%BF%E9%87%8C%E4%BA%91OSS%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/",
            "url": "https://lzq-cv.github.io/%E4%BD%BF%E7%94%A8PICGO-%E9%98%BF%E9%87%8C%E4%BA%91OSS%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/",
            "title": "使用PICGO-阿里云OSS搭建个人图床",
            "date_published": "2025-09-26T10:06:31.000Z",
            "content_html": "<p>使用阿里云 OSS 和 PicGo 搭建图床，可以让你非常方便地将本地图片自动上传到云端，并直接获取可用于博客、文档等处的图片链接。阿里云 OSS 还可以申请 3 个月免费试用。</p>\n<h3 id=\"配置阿里云oss\"><a class=\"anchor\" href=\"#配置阿里云oss\">#</a> 配置阿里云 OSS</h3>\n<p>首先，我们需要在阿里云上创建存储空间（Bucket）并配置访问权限。</p>\n<ol>\n<li>\n<p><strong>创建 Bucket</strong></p>\n<ul>\n<li>登录阿里云控制台，进入<strong>对象存储 OSS</strong> 服务。</li>\n<li>点击<strong>创建 Bucket</strong>，填写 Bucket 名称（全局唯一），选择离你较近的<strong>地域</strong>。</li>\n<li><strong>读写权限</strong>务必设置为<strong>公共读</strong>，这样图片才能被外部访问。其他选项如存储类型等，保持 “标准存储” 默认值即可。</li>\n</ul>\n</li>\n<li>\n<p><strong>创建 RAM 子用户并授权</strong>（为了安全，不建议直接使用主账号 AccessKey）</p>\n<ul>\n<li>进入<strong>访问控制 RAM</strong> 控制台。</li>\n<li>创建一个子用户（例如命名为  <code>picgo-user</code> ），<strong>访问方式</strong>请勾选 <strong>“OpenAPI 调用访问”</strong> 。系统会自动为该子用户创建 AccessKey（即 AccessKey ID 和 AccessKey Secret），请务必妥善保存这两项信息，后续配置 PicGo 时需要用到。</li>\n<li>为这个子用户<strong>添加权限</strong>。建议直接授权系统策略  <code>AliyunOSSFullAccess</code> （管理对象存储服务 OSS 的权限），或者按需授予更小粒度的权限。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"安装与配置picgo\"><a class=\"anchor\" href=\"#安装与配置picgo\">#</a> 安装与配置 PicGo</h3>\n<p>接下来，我们在电脑上配置 PicGo 客户端来连接 OSS。</p>\n<ol>\n<li>\n<p><strong>安装 PicGo</strong></p>\n<ul>\n<li>请前往 PicGo 的 GitHub Releases 页面<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL01vbHVuZXJmaW5uL1BpY0dvL3JlbGVhc2Vz\"> https://github.com/Molunerfinn/PicGo/releases</span> 下载并安装适合你操作系统的版本。</li>\n</ul>\n</li>\n<li>\n<p><strong>配置阿里云 OSS 图床</strong></p>\n<ul>\n<li>打开 PicGo 应用，在左侧<strong>图床设置</strong>中，找到并点击<strong>阿里云 OSS</strong>。</li>\n<li>根据获取的信息填写以下配置项：\n<ul>\n<li><code>AccessKey ID</code>  和  <code>AccessKey Secret</code> ：填入之前保存的子用户的 AccessKey 信息。</li>\n<li><code>Bucket</code> ：填写你创建的 Bucket 名称。</li>\n<li><code>存储区域</code> ：填写 Bucket 所在地域的<strong> Endpoint（访问域名）中的 “节点” 部分</strong>。例如，如果你的 Endpoint 是  <code>oss-cn-hangzhou.aliyuncs.com</code> ，这里就填  <code>oss-cn-hangzhou</code> 。你可以在 Bucket 的概览页面找到这个信息。</li>\n<li><code>存储路径</code> （可选）：可以指定一个文件夹来存放图片，例如  <code>blog/img/</code> 。如果不填，图片会保存在 Bucket 根目录。</li>\n<li><code>自定义域名</code> （可选）：如果你为 Bucket 配置了自定义加速域名（CNAME），可以在这里填写，例如  <code>https://img.example.com</code> 。</li>\n</ul>\n</li>\n<li>填写完毕后，点击<strong>确定</strong>或<strong>设为默认图床</strong>。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"验证上传与高级集成\"><a class=\"anchor\" href=\"#验证上传与高级集成\">#</a> 验证上传与高级集成</h3>\n<ol>\n<li>\n<p><strong>验证图床是否正常工作</strong></p>\n<ul>\n<li>在 PicGo 的<strong>上传区</strong>，拖拽一张图片或点击选择文件，然后点击<strong>上传</strong>。</li>\n<li>上传成功后，PicGo 会自动将图片的 URL 链接复制到你的剪贴板，并会在相册中显示记录。你可以将链接粘贴到浏览器地址栏中访问，确认图片可以正常显示。</li>\n</ul>\n</li>\n<li>\n<p><strong>在 Typora 中集成 PicGo（实现自动上传）</strong></p>\n<ul>\n<li>如果你使用 Typora 编写 Markdown 文档，可以将其与 PicGo 无缝集成。打开 Typora，进入<strong>文件</strong> &gt; <strong>偏好设置</strong> &gt; <strong>图像</strong>。</li>\n<li>在上传服务设置中，选择 <strong>PicGo (app)</strong>，并在下方指定 PicGo 的安装路径。</li>\n<li>点击<strong>验证图片上传选项</strong>，如果提示成功，说明配置正确。之后在 Typora 中插入的本地图片在保存时便会自动上传到 OSS 并替换为网络链接。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"实用技巧与注意事项\"><a class=\"anchor\" href=\"#实用技巧与注意事项\">#</a> 实用技巧与注意事项</h3>\n<p>为了让你的图床更安全、经济地运行，这里还有一些建议：</p>\n<ul>\n<li><strong>安全建议</strong>\n<ul>\n<li><strong>防盗链</strong>：在 OSS Bucket 的<strong>权限管理</strong> &gt; <strong>防盗链</strong>设置中，可以添加允许访问你图片的域名白名单（如你的博客域名、 <code>*.console.aliyun.com</code>  等），防止图片被其他网站盗用。</li>\n<li><strong>权限最小化</strong>：授予子用户的权限遵循最小权限原则，仅授予其必要的 OSS 管理权限。</li>\n</ul>\n</li>\n<li><strong>成本优化</strong>\n<ul>\n<li>阿里云 OSS 的费用主要包括存储容量、流量和请求次数。对于个人博客或小规模使用，消耗通常很低，甚至可以购买资源包来进一步降低成本。</li>\n</ul>\n</li>\n<li><strong>故障排查</strong>\n<ul>\n<li><strong>上传失败</strong>：首先检查 AccessKey、Bucket 名称、存储区域（尤其是区域后缀是否正确）是否填写无误。确保子用户已被正确授权。</li>\n<li><strong>图片无法访问</strong>：检查 Bucket 的读写权限是否为 “公共读”。如果使用了防盗链，请确认当前访问域名是否在白名单中。</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "图床"
            ]
        },
        {
            "id": "https://lzq-cv.github.io/%E4%BD%BF%E7%94%A8PICGO-GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/",
            "url": "https://lzq-cv.github.io/%E4%BD%BF%E7%94%A8PICGO-GitHub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/",
            "title": "使用PICGO-GitHub搭建个人图床",
            "date_published": "2025-09-26T09:55:51.000Z",
            "content_html": "<p>通过 GitHub API 和 jsDelivr CDN 搭建图床，简单说就是<strong>用 GitHub 存图片，用 jsDelivr 加速访问</strong>。这个方案免费、可靠，对开发者尤其友好。</p>\n<h3 id=\"第一步准备工作\"><a class=\"anchor\" href=\"#第一步准备工作\">#</a> 第一步：准备工作</h3>\n<ol>\n<li><strong>创建 GitHub 仓库</strong>：\n<ul>\n<li>登录 GitHub，点击右上角 “+” 号，选择 “New repository”。</li>\n<li>取一个清晰的仓库名（如  <code>my-image-bed</code> ）。</li>\n<li>仓库需设置为 <strong>Public</strong>（公开），因为 jsDelivr 无法加速私有仓库的资源。</li>\n<li>其他设置保持默认，点击 “Create repository”。</li>\n</ul>\n</li>\n<li><strong>生成 GitHub Personal Access Token (PAT)</strong>：\n<ul>\n<li>点击右上角头像 -&gt; “Settings” -&gt; 左侧 “Developer settings” -&gt; “Personal access tokens” -&gt; “Tokens (classic)” -&gt; “Generate new token (classic)”。</li>\n<li>为令牌添加一个<strong>备注</strong>（如  <code>For Image Bed</code> ）。</li>\n<li><strong>选择权限</strong>：务必勾选  <code>repo</code> （完全控制私有仓库）下的所有权限，这样才允许通过 API 管理仓库内的文件。</li>\n<li>生成后，<strong>务必立即复制并妥善保存</strong>这个令牌字符串，关闭页面后就无法再次查看。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"第二步配置上传工具-以-picgo-为例\"><a class=\"anchor\" href=\"#第二步配置上传工具-以-picgo-为例\">#</a> 第二步：配置上传工具 (以 PicGo 为例)</h3>\n<p>手动上传和获取链接比较麻烦，使用工具可以自动化这个过程。<strong>PicGo</strong> 是一个很好的选择。</p>\n<ol>\n<li><strong>下载并安装 PicGo</strong>：从其 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL01vbHVuZXJmaW5uL1BpY0dvL3JlbGVhc2Vz\">GitHub Releases</span> 页面下载并安装。</li>\n<li><strong>安装 GitHub 图床插件</strong>：\n<ul>\n<li>打开 PicGo，在左侧找到 “插件设置”。</li>\n<li>搜索  <code>github-plus</code>  并安装。这个插件功能更丰富。</li>\n</ul>\n</li>\n<li><strong>配置图床设置</strong>：\n<ul>\n<li>在左侧 “图床设置” 中找到 “GitHubPlus”。</li>\n<li>按下表填写信息：</li>\n</ul>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">配置项</th>\n<th style=\"text-align:left\">填写说明</th>\n<th style=\"text-align:left\">示例（需替换为你自己的信息）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\"><strong>仓库名</strong></td>\n<td style=\"text-align:left\">你的 GitHub 用户名 / 仓库名</td>\n<td style=\"text-align:left\"><code>yourusername/my-image-bed</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>分支名</strong></td>\n<td style=\"text-align:left\">一般为  <code>main</code>  或  <code>master</code></td>\n<td style=\"text-align:left\"><code>main</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>Token</strong></td>\n<td style=\"text-align:left\">粘贴你刚才生成的 Personal Access Token</td>\n<td style=\"text-align:left\"><code>ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>存储路径</strong></td>\n<td style=\"text-align:left\">可选。图片在仓库中的存放目录，如  <code>images/</code> 。若不填则保存在仓库根目录。</td>\n<td style=\"text-align:left\"><code>images/</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>自定义域名</strong></td>\n<td style=\"text-align:left\"><strong>非常重要</strong>！填写 jsDelivr 的加速域名，格式： <code>https://cdn.jsdelivr.net/gh/你的用户名/你的仓库名</code></td>\n<td style=\"text-align:left\"><code>https://cdn.jsdelivr.net/gh/yourusername/my-image-bed</code></td>\n</tr>\n<tr>\n<td style=\"text-align:left\"><strong>设置提醒日期</strong></td>\n<td style=\"text-align:left\">可选。由于 PAT 可能有过期时间，建议在此设置提醒，以便及时更新 Token，避免上传失败。</td>\n<td style=\"text-align:left\">在 Token 过期前选择日期</td>\n</tr>\n</tbody>\n</table>\n<ol start=\"4\">\n<li><strong>设为默认图床并上传测试</strong>：配置完成后，将其设为默认图床，然后拖拽一张图片上传试试。成功后，PicGo 会自动将<strong>加速后的图片链接</strong>复制到你的剪贴板。</li>\n</ol>\n<h3 id=\"第三步获取-jsdelivr-加速链接\"><a class=\"anchor\" href=\"#第三步获取-jsdelivr-加速链接\">#</a> 第三步：获取 jsDelivr 加速链接</h3>\n<p>无论你是否使用 PicGo 等工具，图片上传到 GitHub 仓库后，其 jsDelivr 的加速链接都遵循统一的格式：</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://cdn.jsdelivr.net/gh/你的GitHub用户名/你的仓库名@发布的版本号/文件路径</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li><strong> <code>@发布的版本号</code> </strong>：这部分是可选的。可以是分支名（如  <code>@main</code> ）、具体的发布版本号（如  <code>@v1.0</code> ）或提交哈希值。<strong>如果不指定版本，默认会指向最新资源</strong>。\n<ul>\n<li><strong>最佳实践</strong>：对于图床，<strong>通常建议省略  <code>@版本号</code> </strong>，这样总能访问到最新上传的图片。例如：<br />\n <code>https://cdn.jsdelivr.net/gh/yourusername/my-image-bed/images/cat.jpg</code></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"注意事项\"><a class=\"anchor\" href=\"#注意事项\">#</a> 注意事项</h3>\n<ul>\n<li><strong>仓库必须公开</strong>：jsDelivr <strong>无法</strong>加速私有仓库的资源。</li>\n<li><strong>文件大小限制</strong>：jsDelivr 建议文件大小控制在 20MB 以内，这对于绝大多数图片来说足够了。</li>\n<li><strong>缓存问题</strong>：jsDelivr 会对文件进行缓存以提升速度。这意味着如果你更新了 GitHub 仓库中的同名图片，可能需要等待几分钟到几小时缓存刷新后，通过 jsDelivr 链接才能看到变更。<strong>强制更新缓存的方法是在链接后添加特定版本号、分支名或哈希值</strong>。</li>\n<li><strong>Token 安全</strong>：你的 GitHub Token 相当于密码，<strong>切勿泄露</strong>。一旦泄露，应立即到 GitHub 设置中撤销它。</li>\n<li><strong>API 速率限制</strong>：GitHub API 有调用频率限制。对于个人使用通常不会触限，但如果是极高频率调用，需要注意。</li>\n</ul>\n",
            "tags": [
                "图床"
            ]
        },
        {
            "id": "https://lzq-cv.github.io/%E4%BD%BF%E7%94%A8PICGO-CloudflarR2%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/",
            "url": "https://lzq-cv.github.io/%E4%BD%BF%E7%94%A8PICGO-CloudflarR2%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%9B%BE%E5%BA%8A/",
            "title": "使用PICGO-CloudflarR2搭建个人图床",
            "date_published": "2025-09-26T09:54:33.000Z",
            "content_html": "<h3 id=\"cloudflare-r2\"><a class=\"anchor\" href=\"#cloudflare-r2\">#</a> Cloudflare R2</h3>\n<p>自己搭建图床既能掌控数据，又能在长期节省成本。Cloudflare R2 因其<strong>免费额度慷慨</strong>（每月 10GB 存储、100 万次 A 类操作、1000 万次 B 类操作）且<strong>出口流量全免</strong>，成为了一个非常不错的选择。</p>\n<h3 id=\"cloudflare-r2-免费额度\"><a class=\"anchor\" href=\"#cloudflare-r2-免费额度\">#</a> Cloudflare R2 免费额度</h3>\n<p>首先，我们来了解一下 Cloudflare R2 的免费计划：</p>\n<table>\n<thead>\n<tr>\n<th>资源类型</th>\n<th>每月免费额度</th>\n<th>超额费率 (截至 2025 年)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>存储空间</strong></td>\n<td>10 GB</td>\n<td>$0.015 / GB</td>\n</tr>\n<tr>\n<td><strong>A 类操作</strong></td>\n<td>100 万次请求 (写入、列举等)</td>\n<td>$4.50 / 100 万次请求</td>\n</tr>\n<tr>\n<td><strong>B 类操作</strong></td>\n<td>1000 万次请求 (读取等)</td>\n<td>$0.36 / 100 万次请求</td>\n</tr>\n<tr>\n<td><strong>出口流量</strong></td>\n<td><strong>完全免费</strong></td>\n<td><strong>完全免费</strong></td>\n</tr>\n</tbody>\n</table>\n<p><strong>注意</strong>：A 类操作通常包括上传、列举文件等写入操作，而 B 类操作主要是下载、获取文件等读取操作。免费额度对于个人博客或小规模网站通常足够。</p>\n<h3 id=\"搭建步骤\"><a class=\"anchor\" href=\"#搭建步骤\">#</a> 搭建步骤</h3>\n<h3 id=\"第一步准备工作\"><a class=\"anchor\" href=\"#第一步准备工作\">#</a> 第一步：准备工作</h3>\n<ol>\n<li><strong>注册 Cloudflare 账号</strong>：访问 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9kYXNoLmNsb3VkZmxhcmUuY29tL3NpZ24tdXA=\">Cloudflare 官网</span> 并注册账号。</li>\n<li><strong>准备域名</strong>：需要一个<strong>已托管在 Cloudflare 上</strong>的域名（作为图床的最终访问域名）。你可以在 Cloudflare 添加现有的域名，或者注册新域名后将其 DNS 服务器改为 Cloudflare 指定的。</li>\n<li><strong>验证支付方式</strong>：虽然 R2 有免费额度，但 Cloudflare 仍需要你绑定一种支付方式（如信用卡或 PayPal）以验证身份。<strong>只要用量不超额，就不会产生费用</strong>。</li>\n</ol>\n<h3 id=\"第二步配置-cloudflare-r2\"><a class=\"anchor\" href=\"#第二步配置-cloudflare-r2\">#</a> 第二步：配置 Cloudflare R2</h3>\n<ol>\n<li><strong>开通 R2 服务</strong>：\n<ul>\n<li>登录 Cloudflare 仪表板，在侧边栏找到 <strong>“R2”</strong> 并点击。</li>\n<li>按照提示完成支付方式的绑定以开通 R2。</li>\n</ul>\n</li>\n<li><strong>创建存储桶（Bucket）</strong>：\n<ul>\n<li>在 R2 页面点击 <strong>“创建存储桶”</strong>。</li>\n<li>填写存储桶名称（例如  <code>my-image-bed</code> ）。</li>\n<li><strong>地区（Region）</strong> 选择离你的目标用户较近的区域，例如  <code>亚太地区 (APAC)</code>  对国内访问更友好。</li>\n<li>其他设置保持默认，点击创建。</li>\n</ul>\n</li>\n<li><strong>启用公共访问权限</strong>：\n<ul>\n<li>创建成功后，进入该存储桶的 <strong>“设置”</strong> 页。</li>\n<li>找到 <strong>“公共访问”</strong> 选项，点击 <strong>“启用”</strong> 并确认。这将生成一个临时的  <code>r2.dev</code>  子域名用于访问文件。</li>\n<li><strong>（强烈推荐）使用自定义域名</strong>：临时的  <code>r2.dev</code>  域名有速率限制。在存储桶设置的 <strong>“自定义域”</strong> 部分，添加你已托管在 CF 的域名（例如  <code>img.yourdomain.com</code> ）。Cloudflare 会自动为你配置 DNS 记录。</li>\n</ul>\n</li>\n<li><strong>获取 API 凭证</strong>：\n<ul>\n<li>在仪表板左侧栏找到 <strong>“R2” &gt; “API 令牌”</strong>。</li>\n<li>点击 <strong>“创建 API 令牌”</strong>。</li>\n<li>选择 <strong>“编辑”</strong> 权限，并指定到你刚创建的存储桶。</li>\n<li>安全起见，可以设置令牌的 TTL（生存时间），对于长期使用的图床，可选择永久。</li>\n<li>创建成功后，<strong>务必妥善保存</strong>显示的  <code>访问密钥 ID</code>  和  <code>秘密访问密钥</code> ，它们只会显示一次。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"第三步配置图床管理工具以-picgo-为例\"><a class=\"anchor\" href=\"#第三步配置图床管理工具以-picgo-为例\">#</a> 第三步：配置图床管理工具（以 PicGo 为例）</h3>\n<p>PicGo 是一个开源图床客户端，可以简化上传操作。</p>\n<ol>\n<li><strong>下载并安装 PicGo</strong>：\n<ul>\n<li>访问 PicGo 的 <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL01vbHVuZXJmaW5uL1BpY0dvL3JlbGVhc2Vz\">GitHub Releases 页面</span>，下载并安装适合你操作系统的最新版本。</li>\n</ul>\n</li>\n<li><strong>安装 S3 插件</strong>：\n<ul>\n<li>由于 Cloudflare R2 兼容 S3 API，我们需要在 PicGo 中安装 S3 插件。</li>\n<li>打开 PicGo，进入 <strong>“插件设置”</strong>。</li>\n<li>搜索并安装  <code>picgo-plugin-s3</code>  插件。</li>\n</ul>\n</li>\n<li><strong>配置 PicGo</strong>：\n<ul>\n<li>安装插件后，在 <strong>“图床设置”</strong> 中找到 <strong>“Amazon S3”</strong> 进行配置。</li>\n<li>关键配置项如下（请根据你的实际情况填写）：</li>\n</ul>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th>配置项</th>\n<th>填写值说明</th>\n<th>示例（请替换为你自己的信息）</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>应用密钥 ID</strong></td>\n<td>填写你刚才保存的  <code>访问密钥 ID</code></td>\n<td><code>1a2b3c4d5e6f7g8h9i0j</code></td>\n</tr>\n<tr>\n<td><strong>应用密钥</strong></td>\n<td>填写你刚才保存的  <code>秘密访问密钥</code></td>\n<td><code>z0y1x2w3v4u5t6s7r8q9p...</code></td>\n</tr>\n<tr>\n<td><strong>存储桶名</strong></td>\n<td>你创建的存储桶名称</td>\n<td><code>my-image-bed</code></td>\n</tr>\n<tr>\n<td><strong>存储区域</strong></td>\n<td>R2 无需填写特定区域，可填写  <code>auto</code>  或留空</td>\n<td><code>auto</code></td>\n</tr>\n<tr>\n<td><strong>自定义节点</strong></td>\n<td>填写你的 S3 API 端点（可在 R2 的 API 令牌页面找到）</td>\n<td><code>https://xxx.r2.cloudflarestorage.com</code></td>\n</tr>\n<tr>\n<td><strong>自定义域名</strong></td>\n<td><strong>填写你连接到存储桶的自定义域名</strong>，用于生成图片链接</td>\n<td><code>https://img.yourdomain.com</code></td>\n</tr>\n<tr>\n<td><strong>文件路径</strong></td>\n<td>定义图片在存储桶中的存储路径结构（可选，但建议设置以保持整洁）</td>\n<td><code>{year}/{month}/{day}/{fileName}</code></td>\n</tr>\n<tr>\n<td><strong>ACL 访问控制列表</strong></td>\n<td>必须设置为  <code>public-read</code> ，这样图片链接才能被公开访问</td>\n<td><code>public-read</code></td>\n</tr>\n</tbody>\n</table>\n<p><strong>提示</strong>： <code>{year}</code> ,  <code>{month}</code> ,  <code>{day}</code> ,  <code>{fileName}</code>  是 PicGo 的<strong>变量</strong>，会自动替换为实际值。</p>\n<ol>\n<li><strong>设为默认图床并上传测试</strong>：\n<ul>\n<li>配置完成后，可以点击 <strong>“设为默认图床”</strong>。</li>\n<li>在 <strong>“上传区”</strong> 拖拽或选择一张图片进行上传。</li>\n<li>上传成功后，PicGo 会自动将图片的 Markdown 链接复制到剪贴板。你可以粘贴到文本编辑器中测试一下是否能正常访问。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"第四步访问优化与安全设置可选但重要\"><a class=\"anchor\" href=\"#第四步访问优化与安全设置可选但重要\">#</a> 第四步：访问优化与安全设置（可选但重要）</h3>\n<p>为了让图床更高效、安全，建议进行如下设置：</p>\n<ol>\n<li><strong>配置缓存规则</strong>：利用 Cloudflare CDN 缓存图片，减少回源请求，提升速度并节省操作次数。\n<ul>\n<li>在 Cloudflare 仪表板中，进入你的<strong>域名</strong>（而非 R2）。</li>\n<li>转到 <strong>“规则” &gt; “缓存规则”</strong>。</li>\n<li>创建一条新规则，URL 填写  <code>img.yourdomain.com/*</code> （你的图床域名）。</li>\n<li>添加设置：<strong>缓存级别</strong> - 缓存所有内容。</li>\n<li>添加设置：<strong>边缘缓存 TTL</strong> - 设置为一个较长的时间，例如 “1 个月”。</li>\n</ul>\n</li>\n<li><strong>设置防盗链（WAF）</strong>：防止其他网站直接链接你的图片，消耗你的流量和请求次数。\n<ul>\n<li>在域名的 <strong>“安全性” &gt; “WAF”</strong> 中创建自定义规则。</li>\n<li>编写规则，例如： <code>(http.referer does not contain &quot;yourdomain.com&quot;) and (http.request.uri.path contains &quot;/images/&quot;)</code> ，操作选择 “阻止”。这表示仅允许来自你自己域名（ <code>yourdomain.com</code> ）的请求访问图片目录。</li>\n</ul>\n</li>\n<li><strong>配置 CORS（跨域资源共享）</strong>：如果你的图床图片需要被不同域名的网站引用（例如你的主站、CDN 等），需要在存储桶设置中配置 CORS。\n<ul>\n<li>在存储桶的 <strong>“设置”</strong> 中找到 <strong>“CORS 策略”</strong>。</li>\n<li>添加策略，允许所需域名的  <code>GET</code>  请求。</li>\n</ul>\n</li>\n</ol>\n<h3 id=\"总结与提醒\"><a class=\"anchor\" href=\"#总结与提醒\">#</a> 总结与提醒</h3>\n<p>通过以上步骤，你应该已经成功搭建了一个基于 Cloudflare R2 的免费图床。它<strong>免费额度充足</strong>、<strong>性能可靠</strong>，并且通过 PicGo 可以<strong>非常便捷地上传和管理图片</strong>。</p>\n<p>最后请注意：</p>\n<ul>\n<li><strong>保管好 API 令牌</strong>：如同密码，切勿泄露。</li>\n<li><strong>关注用量</strong>：定期在 Cloudflare 仪表板检查 R2 的使用情况，确保在免费额度内。</li>\n<li><strong>备份重要图片</strong>：虽然 R2 很可靠，但对于极其重要的图片，建议额外备份。</li>\n</ul>\n",
            "tags": [
                "图床"
            ]
        },
        {
            "id": "https://lzq-cv.github.io/%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A%E8%B8%A9%E5%9D%91/",
            "url": "https://lzq-cv.github.io/%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A%E8%B8%A9%E5%9D%91/",
            "title": "免费图床踩坑",
            "date_published": "2025-09-26T09:52:04.000Z",
            "content_html": "<h3 id=\"踩坑\"><a class=\"anchor\" href=\"#踩坑\">#</a> 踩坑</h3>\n<p>免费的图床是真的不稳定，上传的图片随时都有被清除的可能，想要长期使用还是需要自己搭建图床。但是，我对图床需求又不是特别多，只为博客网站提供图片源仅此而已。花钱去买阿里云 OSS 和腾讯云 COS 的云存储服务，又不太值。查了一些免费图床搭建方法，目前就 2 种比较推荐的：</p>\n<p>方法 1：CloudflareR2+PICGO</p>\n<p>方法 2：Github+PICGO</p>\n<h3 id=\"临时使用的免费图床\"><a class=\"anchor\" href=\"#临时使用的免费图床\">#</a> 临时使用的免费图床：</h3>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9pbWcuMTMxMjEzLnh5ei8=\">图床</span></p>\n",
            "tags": [
                "图床"
            ]
        },
        {
            "id": "https://lzq-cv.github.io/shoka%E4%B8%BB%E9%A2%98%E9%83%A8%E7%BD%B2/",
            "url": "https://lzq-cv.github.io/shoka%E4%B8%BB%E9%A2%98%E9%83%A8%E7%BD%B2/",
            "title": "shoka主题部署",
            "date_published": "2025-09-26T09:48:44.000Z",
            "content_html": "<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">先要搭建好HEXO博客框架</span><br><span class=\"line\"># cd your-blog</span><br><span class=\"line\">git clone https://github.com/amehime/hexo-theme-shoka.git ./themes/shoka</span><br></pre></td></tr></table></figure></p>\n<p>1.<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaGV4by1yZW5kZXJlci1tdWx0aS1tYXJrZG93bi1pdA==\">https://www.npmjs.com/package/hexo-renderer-multi-markdown-it</span></p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm un hexo-renderer-marked --save</span><br><span class=\"line\">npm i hexo-renderer-multi-markdown-it --save</span><br><span class=\"line\">npm un hexo-renderer-multi-markdown-it --save</span><br><span class=\"line\"></span><br><span class=\"line\"># 1. 卸载旧渲染器 (如果已安装)</span><br><span class=\"line\">npm uninstall hexo-renderer-marked --save</span><br><span class=\"line\"></span><br><span class=\"line\"># 2. 设置跳过 Chromium 下载</span><br><span class=\"line\">set PUPPETEER_SKIP_DOWNLOAD=1  # Windows CMD</span><br><span class=\"line\"></span><br><span class=\"line\"># 3. 安装插件</span><br><span class=\"line\">npm i hexo-renderer-multi-markdown-it --save</span><br><span class=\"line\"></span><br><span class=\"line\"># 4. 验证安装</span><br><span class=\"line\">npm list hexo-renderer-multi-markdown-it</span><br></pre></td></tr></table></figure></p>\n<p>2.<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaGV4by1hdXRvcHJlZml4ZXI=\">https://www.npmjs.com/package/hexo-autoprefixer</span></p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-autoprefixer --save</span><br></pre></td></tr></table></figure></p>\n<p>3.<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaGV4by1hbGdvbGlhc2VhcmNo\">https://www.npmjs.com/package/hexo-algoliasearch</span></p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-algoliasearch --save</span><br></pre></td></tr></table></figure></p>\n<p>4.<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaGV4by1zeW1ib2xzLWNvdW50LXRpbWU=\">https://www.npmjs.com/package/hexo-symbols-count-time</span></p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-symbols-count-time</span><br></pre></td></tr></table></figure></p>\n<p>5.<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvaGV4by1mZWVk\">https://www.npmjs.com/package/hexo-feed</span></p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-feed --save-dev</span><br></pre></td></tr></table></figure></p>\n",
            "tags": [
                "shoka"
            ]
        },
        {
            "id": "https://lzq-cv.github.io/HEXO%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/",
            "url": "https://lzq-cv.github.io/HEXO%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/",
            "title": "HEXO博客搭建",
            "date_published": "2025-09-26T09:43:28.000Z",
            "content_html": "<h2 id=\"hexo博客搭建\"><a class=\"anchor\" href=\"#hexo博客搭建\">#</a> HEXO 博客搭建</h2>\n<h4 id=\"1-hexo\"><a class=\"anchor\" href=\"#1-hexo\">#</a> 1. HEXO</h4>\n<p>Hexo 是一个基于 Node.js 的快速、简洁的静态博客框架，适合通过 Markdown 编写内容并生成静态网页。有以下优点：</p>\n<ul>\n<li>** 支持 Markdown：** 文章以 Markdown 格式编写，简单易用。</li>\n<li>** 部署简单：** 一键部署到 GitHub Pages、Netlify 等平台，与 GitHub Pages 无缝集成。</li>\n<li>** 主题丰富：** 社区活跃，主题和插件丰富。</li>\n<li>** 高效快速：** 利用 Node.js 高效渲染，快速生成静态页面。轻量快速，适合博客和文档。</li>\n</ul>\n<h4 id=\"2-环境搭建\"><a class=\"anchor\" href=\"#2-环境搭建\">#</a> 2. 环境搭建</h4>\n<p>首先在官网下载并安装好 node.js 和 git。</p>\n<p>node.js 官网：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9ub2RlanMub3JnL3poLWNuL2Rvd25sb2Fk\">https://nodejs.org/zh-cn/download</span></p>\n<p>git 官网：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXQtc2NtLmNvbS9kb3dubG9hZHM=\">https://git-scm.com/downloads</span></p>\n<p>然后，打开 cmd 或者鼠标右键 git bash here，搭建本地 HEXO 博客。</p>\n<p>HEXO 官网：<span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL3poLWNuLw==\">https://hexo.io/zh-cn/</span></p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-cli -g <span class=\"comment\">#安装hexo命令行工具</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#包管理工具</span></span><br><span class=\"line\">npm install -g pnpm <span class=\"comment\">#安装pnpm</span></span><br><span class=\"line\">pnpm config <span class=\"built_in\">set</span> registry https://registry.npmmirror.com/</span><br><span class=\"line\">npm install -g yarn <span class=\"comment\">#安装yarn</span></span><br><span class=\"line\">yarn config <span class=\"built_in\">set</span> registry https://registry.npmmirror.com/</span><br><span class=\"line\"></span><br><span class=\"line\">hexo init LZQ-CV.github.io <span class=\"comment\">#初始化创建</span></span><br><span class=\"line\"><span class=\"built_in\">cd</span> LZQ-CV.github.io  <span class=\"comment\">#进入创建的项目目录</span></span><br><span class=\"line\">npm install <span class=\"comment\">#安装依赖</span></span><br><span class=\"line\"></span><br><span class=\"line\">hexo new <span class=\"built_in\">test</span> <span class=\"comment\">#生成test.md文件</span></span><br><span class=\"line\"></span><br><span class=\"line\">hexo clean <span class=\"comment\">#清除缓存</span></span><br><span class=\"line\">hexo generate <span class=\"comment\">#生成禁态页面</span></span><br><span class=\"line\"></span><br><span class=\"line\">hexo server <span class=\"comment\">#启动本地服务器</span></span><br><span class=\"line\">hexo deploy <span class=\"comment\">#远程部署</span></span><br><span class=\"line\"></span><br><span class=\"line\">npm install hexo-deployer-git --save</span><br><span class=\"line\">pnpm install hexo-deployer-git --save <span class=\"comment\">#安装git部署插件</span></span><br><span class=\"line\">git init <span class=\"comment\">#git初始化</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">node_modules用于放置NPM包,无需注意</span><br><span class=\"line\">scaffolds储存文章模板,hexo new时会用到</span><br><span class=\"line\"><span class=\"built_in\">source</span>储存文章和部分资源</span><br><span class=\"line\">themes储存主题</span><br><span class=\"line\">_config.xxx.yml是主题的plus版配置文件(xxx须更改为主题名)</span><br><span class=\"line\">_config.yml是hexo的配置文件</span><br><span class=\"line\">package.jsonNPM的包json,无需注意</span><br></pre></td></tr></table></figure></p>\n<p>打开项目文件夹，找到_config.yml 并修改。</p>\n<p><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: https://LZQ-CV:填入token开发者令牌@github.com/LZQ-CV/LZQ-CV.github.io.git</span><br><span class=\"line\">  #远程仓库路径有HTTPs和SSH的区别，这里使用的是https。</span><br><span class=\"line\">  repo: git@github.com:LZQ-CV/LZQ-CV.github.io.git</span><br><span class=\"line\">  #远程仓库路径有HTTPs和SSH的区别，这里使用的是SSH。</span><br><span class=\"line\">  branch: main #GitHub仓库默认分支</span><br><span class=\"line\">  </span><br></pre></td></tr></table></figure></p>\n<p>安装 HEXO 的主题</p>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/theme-next/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p>\n<p>修改  <code>_config.yml</code>  中的  <code>theme: next</code> 。</p>\n<p>也可以直接把下载好的主题放到项目文件夹的 themes 文件夹中。</p>\n<h4 id=\"3远程部署到github\"><a class=\"anchor\" href=\"#3远程部署到github\">#</a> 3. 远程部署到 GitHub</h4>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git config --global user.email <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">git config --global user.name <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">git config --global --list <span class=\"comment\">#查看是否配置成功</span></span><br><span class=\"line\">ssh-keygen -t rsa -C <span class=\"string\">&quot;email&quot;</span> <span class=\"comment\">#生成ssh公钥</span></span><br><span class=\"line\">ssh -T git@github.com <span class=\"comment\">#验证是否链接成功</span></span><br><span class=\"line\"></span><br><span class=\"line\">hexo deploy <span class=\"comment\">#部署</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure></p>\n",
            "tags": [
                "HEXO"
            ]
        },
        {
            "id": "https://lzq-cv.github.io/hello-world/",
            "url": "https://lzq-cv.github.io/hello-world/",
            "title": "Hello World",
            "date_published": "2025-09-26T08:47:49.801Z",
            "content_html": "<p>Welcome to <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvLw==\">Hexo</span>! This is your very first post. Check <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv\">documentation</span> for more info. If you get any problems when using Hexo, you can find the answer in <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvdHJvdWJsZXNob290aW5nLmh0bWw=\">troubleshooting</span> or you can ask me on <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2hleG9qcy9oZXhvL2lzc3Vlcw==\">GitHub</span>.</p>\n<h2 id=\"quick-start\"><a class=\"anchor\" href=\"#quick-start\">#</a> Quick Start</h2>\n<h3 id=\"create-a-new-post\"><a class=\"anchor\" href=\"#create-a-new-post\">#</a> Create a new post</h3>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></p>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvd3JpdGluZy5odG1s\">Writing</span></p>\n<h3 id=\"run-server\"><a class=\"anchor\" href=\"#run-server\">#</a> Run server</h3>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure></p>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvc2VydmVyLmh0bWw=\">Server</span></p>\n<h3 id=\"generate-static-files\"><a class=\"anchor\" href=\"#generate-static-files\">#</a> Generate static files</h3>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure></p>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3MvZ2VuZXJhdGluZy5odG1s\">Generating</span></p>\n<h3 id=\"deploy-to-remote-sites\"><a class=\"anchor\" href=\"#deploy-to-remote-sites\">#</a> Deploy to remote sites</h3>\n<p><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure></p>\n<p>More info: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oZXhvLmlvL2RvY3Mvb25lLWNvbW1hbmQtZGVwbG95bWVudC5odG1s\">Deployment</span></p>\n",
            "tags": []
        }
    ]
}